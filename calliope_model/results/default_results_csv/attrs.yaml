definition:
  data_definitions:
    objective_cost_weights:
      data: 1
      dims: costs
      index: monetary
    bigM: 1000000.0
  data_tables:
    demand:
      data: input_data_tables/demand_year.csv
      rows: timesteps
      columns:
      - nodes
      - techs
      select:
      drop:
      add_dims:
        parameters: sink_use_equals
      rename_dims:
    renewables:
      data: input_data_tables/renewables_year.csv
      rows: timesteps
      columns:
      - nodes
      - techs
      select:
        techs:
        - solar_pv
        - wind_onshore
      drop:
      add_dims:
        parameters: source_use_equals
      rename_dims:
  nodes:
    NLD:
      active: true
      latitude: 40.4167
      longitude: 3.7033
      techs:
        demand_power:
        curtailment:
        load_shedding:
        ccgt:
          flow_cap: 34158
        nuclear:
          flow_cap: 6000
        hydro:
          flow_cap: 17077
        wind_onshore:
          flow_cap: 33008
        solar_pv:
          flow_cap: 40945
  techs:
    load_shedding:
      active: true
      base_tech: supply
      cost_interest_rate:
        data: 0.07
        dims: costs
        index: monetary
      name: Shed load due to insufficient generation
      color: '#000000'
      carrier_out: power
      lifetime: 50
      cost_flow_out:
        data: 0.25
        dims: costs
        index: monetary
    ccgt:
      active: true
      base_tech: supply
      cost_interest_rate:
        data: 0.07
        dims: costs
        index: monetary
      name: Combined cycle gas turbine
      color: '#E37A72'
      carrier_out: power
      flow_out_eff: 0.57
      flow_ramping: 0.8
      lifetime: 30
      cost_flow_cap:
        data: 100
        dims: costs
        index: monetary
      cost_flow_in:
        data: 0.027
        dims: costs
        index: monetary
      cost_flow_out:
        data: 0.002135
        dims: costs
        index: monetary
    nuclear:
      active: true
      base_tech: supply
      cost_interest_rate:
        data: 0.07
        dims: costs
        index: monetary
      name: Nuclear power plant
      color: '#F3007A'
      carrier_out: power
      flow_out_eff: 0.33
      flow_ramping: 0.3
      lifetime: 40
      cost_flow_cap:
        data: 5000
        dims: costs
        index: monetary
      cost_flow_out:
        data: 0.0075
        dims: costs
        index: monetary
      cost_flow_in:
        data: 0.001692
        dims: costs
        index: monetary
    hydro:
      active: true
      base_tech: supply
      cost_interest_rate:
        data: 0.07
        dims: costs
        index: monetary
      name: Hydro power plant
      color: '#7900f3'
      carrier_out: power
      flow_out_eff: 0.9
      flow_ramping: 1.0
      lifetime: 60
      cost_flow_cap:
        data: 4500
        dims: costs
        index: monetary
      cost_flow_out:
        data: 0.012
        dims: costs
        index: monetary
    solar_pv:
      active: true
      base_tech: supply
      cost_interest_rate:
        data: 0.07
        dims: costs
        index: monetary
      name: Solar photovoltaic power
      color: '#F9D956'
      carrier_out: power
      source_unit: per_cap
      lifetime: 25
      cost_flow_cap:
        data: 885
        dims: costs
        index: monetary
      cost_flow_in:
        data: 1.06e-05
        dims: costs
        index: monetary
    wind_onshore:
      active: true
      base_tech: supply
      cost_interest_rate:
        data: 0.07
        dims: costs
        index: monetary
      name: Wind power onshore
      color: '#56F9C0'
      carrier_out: power
      source_unit: per_cap
      lifetime: 25
      cost_flow_cap:
        data: 1790
        dims: costs
        index: monetary
      cost_flow_out:
        data: 0.001508
        dims: costs
        index: monetary
    demand_power:
      active: true
      base_tech: demand
      name: Power demand
      color: '#072486'
      carrier_in: power
    curtailment:
      active: true
      base_tech: demand
      name: Power curtailment
      color: '#000000'
      carrier_in: power
      sink_use_max: 40000
config:
  init:
    name: NL Power System dispatch example
    calliope_version: 0.7.0.dev7
    broadcast_input_data: false
    subset:
      timesteps:
      - '2024-10-01'
      - '2025-09-30'
    resample: {}
    time_cluster:
    datetime_format: ISO8601
    date_format: ISO8601
    distance_unit: km
    mode: base
    extra_math:
    - operate
    math_paths: {}
    pre_validate_math_strings: false
  build:
    backend: pyomo
    ensure_feasibility: false
    objective: min_cost_optimisation
    operate:
      window: 24h
      horizon: 48h
  solve:
    postprocessing_active: true
    save_logs:
    shadow_prices:
    - system_balance
    solver: gurobi
    solver_io:
    solver_options:
      Threads: 6
      Method: 2
      Crossover: 0
      FeasibilityTol: 0.001
      OptimalityTol: 0.0001
      BarConvTol: 0.0001
    spores:
      scoring_algorithm: integer
      number: 3
      save_per_spore_path:
      use_latest_results: false
      tracking_parameter:
      score_threshold_factor: 0.1
    zero_threshold: 1e-10
math:
  init:
    base:
      dimensions:
        carriers:
          title: Energy / commodity carriers
          dtype: string
          ordered: false
          iterator: carrier
        costs:
          title: Cost classes
          dtype: string
          ordered: false
          iterator: cost
        nodes:
          title: Geographic spatial nodes
          dtype: string
          ordered: false
          iterator: node
        techs:
          title: Technologies
          dtype: string
          ordered: false
          iterator: tech
        timesteps:
          title: Time steps
          dtype: datetime
          ordered: true
          iterator: timestep
        clusters:
          title: Date clusters
          dtype: integer
          ordered: true
          iterator: cluster
        datesteps:
          title: Date steps
          dtype: date
          ordered: true
          iterator: datestep
      parameters:
        area_use_max:
          default: .inf
          title: Maximum usable area.
          description: If set to a finite value, limits the upper bound of the 
            `area_use` decision variable to this value.
          unit: $\text{area}$
        area_use_min:
          default: 0
          title: Minimum usable area.
          description: Limits the lower bound of the `area_use` decision 
            variable to this value.
          unit: $\text{area}$
        area_use_per_flow_cap:
          default: .nan
          title: Area use per flow capacity
          description: If set, forces `area_use` to follow `flow_cap` with the 
            given numerical ratio (e.g. setting to 1.5 means that `area_use == 
            1.5 * flow_cap`).
          unit: $\frac{\text{area}}{\text{power}}$
        available_area:
          default: .inf
          title: Available area
          description: Available area for resource area use by all technologies 
            at a node.
          resample_method: mean
          unit: area.
        bigM:
          default: 1000000.0
          title: Big M
          description: BigM is a large value used to define certain optimisation
            problems. See https://en.wikipedia.org/wiki/Big_M_method for more 
            information. This value should be larger than the largest values 
            that any decision variables can take, but should not be **too** 
            large (i.e., do not set it greater than 3 orders of magnitude above 
            the numeric range of the model). If too large, numerical problems 
            may arise in the optimisation.
          unit: unitless
        cost_flow_cap_per_distance:
          default: 0
          title: Cost of flow capacity, per unit distance
          description: Cost per unit of the decision variable `flow_cap` and per
            unit distance of a transmission link. Applied to transmission links 
            only.
          unit: $\frac{\{cost}}{\text{power}\times\text{distance}}$
        cost_purchase_per_distance:
          default: 0
          title: Purchase cost per unit distance for transmission techs.
          description: Cost applied if the binary variable `purchased` is 1 or 
            per unit of the integer variable `units`. Requires the parameter 
            `cap_method` to be `integer`.
          unit: $\frac{\{cost}}{\text{unit}\times\text{distance}}$
        cost_flow_cap:
          default: 0
          title: Cost of flow capacity.
          description: Cost per unit of the decision variable `flow_cap`.
          unit: $\frac{\{cost}}{\text{power}}$
        cost_export:
          default: 0
          resample_method: mean
          title: Carrier export cost.
          description: Cost per unit of `flow_export` in each timestep. Usually 
            used in the negative sense, as a subsidy.
          unit: $\frac{\{cost}}{\text{energy}}$
        cost_interest_rate:
          default: 0
          title: Interest rate.
          description: Used when computing levelized costs and technology 
            depreciation_rate (relative to lifetime).
          unit: unitless
        cost_om_annual:
          default: 0
          title: Annual O&M costs
          description: Annual costs applied per unit `flow_cap`. These costs are
            not subject to being recalculated relative to technology lifetime, 
            only scaled to reflect the fraction of one year that the model 
            represents (e.g., 7 days ~= 0.02 of a year).
          unit: $\frac{\{cost}}{\text{power}}$
        cost_om_annual_investment_fraction:
          default: 0
          title: Fractional annual O&M costs.
          description: Add an additional cost to total investment costs (except 
            `cost_om_annual`) that is a fraction of that total.
          unit: unitless.
        cost_flow_in:
          default: 0
          resample_method: mean
          title: Carrier inflow cost.
          description: Cost per unit of `flow_in` in each timestep. Also used as
            the cost per unit of `source_use` in `supply` technologies.
          unit: $\frac{\{cost}}{\text{energy}}$
        cost_flow_out:
          default: 0
          resample_method: mean
          title: Carrier outflow cost
          description: Cost per unit of `flow_out` in each timestep.
          unit: $\frac{\{cost}}{\text{energy}}$
        cost_purchase:
          default: 0
          title: Purchase cost.
          description: Cost applied to the variable `purchased_units`. Requires 
            the parameter `cap_method` to be `integer`.
          unit: $\frac{\{cost}}{\text{unit}}$
        cost_area_use:
          default: 0
          title: Cost of area use.
          description: Cost per unit `area_use`.
          unit: $\text{area}$
        cost_source_cap:
          default: 0
          title: Cost of source flow capacity.
          description: Cost per unit `source_cap`.
          unit: $\frac{\{cost}}{\text{power}}$
        cost_storage_cap:
          default: 0
          title: Cost of storage capacity.
          description: Cost per unit `storage_cap`, i.e., the maximum available 
            capacity of the storage technology's "reservoir".
          unit: $\frac{\{cost}}{\text{energy}}$
        cost_depreciation_rate:
          default: 1
          title: Depreciation rate.
          description: Applied to "annualise" investment costs so they are 
            comparable to variable costs. If not provided, this will be 
            calculated using technology `lifetime` and `cost_interest_rate`.
          unit: unitless.
        distance:
          default: 1.0
          resample_method: mean
          title: Distance spanned by link.
          description: Used for `..._per_distance` constraints. If not defined, 
            it will be automatically derived from latitude/longitude of nodes in
            a link.
          unit: distance.
        export_max:
          default: .inf
          title: Maximum allowed carrier export
          description: If `carrier_export` is defined, limit the allowed export 
            of produced carrier for a technology.
          unit: power.
        export_min:
          default: 0
          title: Minimum allowed carrier export
          description: If `carrier_export` is defined, set a lower bound on the 
            amount of produced carrier that _must_ be exported for a technology.
          unit: power.
        flow_cap_per_storage_cap_min:
          default: 0
          title: Minimum flow capacity per storage capacity
          description: ratio of minimum charge/discharge (kW) for a given 
            storage capacity (kWh).
          unit: $\text{hour}^{-1}$
        flow_cap_per_storage_cap_max:
          default: .inf
          title: Maximum flow capacity per storage capacity
          description: ratio of maximum charge/discharge (kW) for a given 
            storage capacity (kWh).
          unit: $\text{hour}^{-1}$
        flow_cap_max:
          default: .inf
          title: Maximum rated flow capacity.
          description: Limits `flow_cap` to a maximum.
          unit: power.
        flow_cap_max_systemwide:
          default: .inf
          title: System-wide maximum rated flow capacity.
          description: Limits the sum of `flow_cap` over all nodes in the model 
            to a maximum. If `cap_method=integer`, this will be scaled by the 
            number of integer units of a technology purchased.
          unit: power or $\frac{\text{power}}{\text{unit}}$
        flow_cap_min:
          default: 0
          title: Minimum rated flow capacity.
          description: 'Limits `flow_cap` to a minimum. NOTE: this will _force_ `flow_cap`
            to a minimum value unless `cap_method` is set to `integer`. If `cap_method=integer`,
            this will be scaled by the number of integer units of a technology purchased.'
          unit: power or $\frac{\text{power}}{\text{unit}}$
        flow_cap_min_systemwide:
          default: 0
          title: System-wide minimum rated flow capacity.
          description: 'Limits the sum of `flow_cap` over all nodes in the model to
            a minimum. NOTE: this will _force_ the sum of `flow_cap` to a minimum
            value unless `cap_method` is set to `integer`.'
          unit: power.
        flow_out_min_relative:
          default: 0
          resample_method: mean
          title: Minimum outflow
          description: Set to a value between 0 and 1 to force minimum 
            `flow_out` as a fraction of the technology rated capacity. If 
            non-zero and `cap_method` is `continuous`, this will force the 
            technology to operate above its minimum value at every timestep.
          unit: unitless.
        flow_cap_per_unit:
          default: .inf
          title: Flow capacity per purchased unit
          description: Set the capacity of each integer unit of a technology 
            purchased, if `cap_method` is `integer`.
          unit: $\frac{\text{power}}{\text{unit}}$
        flow_in_eff:
          default: 1.0
          resample_method: mean
          title: Inflow efficiency
          description: Conversion efficiency from `source`/`flow_in` (tech 
            dependent) into the technology. Set as value between 1 (no loss) and
            0 (all lost).
          unit: unitless.
        flow_in_eff_per_distance:
          default: 1.0
          resample_method: mean
          title: Inflow (i.e., export from node) efficiency per distance of 
            transmission links.
          description: Total link efficiency will be calculated as 
            $\text{flow\_in\_eff}\times{}\text{flow\_in\_eff\_per\_distance}^\text{distance}$.
            Set as value between 1 (no loss) and 0 (all lost).
          unit: $\frac{\text{1}}{\text{distance}}$
        flow_out_eff:
          default: 1.0
          resample_method: mean
          title: Outflow efficiency
          description: Conversion efficiency from the technology to 
            `sink`/`flow_out` (tech dependent). Set as value between 1 (no loss)
            and 0 (all lost).
          unit: unitless.
        flow_out_eff_per_distance:
          default: 1.0
          resample_method: mean
          title: Outflow (i.e., import from node) efficiency per distance of 
            transmission links.
          description: Total link efficiency will be calculated as 
            $\text{flow\_out\_eff}\times{}\text{flow\_out\_eff\_per\_distance}^\text{distance}$.
            Set as value between 1 (no loss) and 0 (all lost).
          unit: $\frac{\text{1}}{\text{distance}}$
        flow_out_parasitic_eff:
          default: 1.0
          resample_method: mean
          title: Plant parasitic efficiency
          description: Additional losses as flow gets transferred from the plant
            to the carrier, e.g. due to plant parasitic consumption. Set as 
            value between 1 (no loss) and 0 (all lost).
          unit: unitless.
        flow_ramping:
          default: 1.0
          title: Ramping rate
          description: limit maximum outflow / inflow / outflow - inflow 
            (technology base class dependent) to a fraction of maximum capacity,
            which increases by that fraction at each timestep.
          unit: $\frac{1}{\text{hour}}$
        lifetime:
          default: .inf
          resample_method: mean
          title: Technology lifetime
          description: Must be defined if fixed capital costs are defined. A 
            reasonable value for many technologies is around 20-25 years.
          unit: years.
        objective_cost_weights:
          default: 1
          title: Objective cost class weights.
          description: Weightings for cost classes to apply in the objective 
            function.
          unit: unitless
        purchased_units_min_systemwide:
          default: 0
          title: System-wide minimum installed integer units of a technology.
          description: sets the lower bound of the sum across all nodes of the 
            decision variable `units` for a particular technology.
          unit: integer.
        purchased_units_max_systemwide:
          default: .inf
          title: System-wide maximum installed integer units of a technology.
          description: sets the upper bound of the sum across all nodes of the 
            decision variable `units` for a particular technology.
          unit: integer.
        purchased_units_min:
          default: 0
          title: Minimum number of purchased units
          description: Limits the lower bound of units purchased if `cap_method`
            is `integer`.
          unit: integer.
        purchased_units_max:
          default: .inf
          title: Maximum number of purchased units.
          description: Limits the upper bound of units purchased if `cap_method`
            is `integer`. If set to `1`, will effectively set the 
            `purchased_units` to a binary decision variable.
          unit: integer.
        sink_use_min:
          default: 0
          resample_method: sum
          title: Minimum bound on sink.
          description: Minimum sink use to remove a carrier from the system 
            (e.g., electricity demand, transport distance). Unit dictated by 
            `source_unit`.
          unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
            $\frac{\text{energy}}{\text{area}}$
        sink_use_max:
          default: .inf
          resample_method: sum
          title: Maximum bound on sink.
          description: Maximum sink use to remove a carrier from the system 
            (e.g., electricity demand, transport distance). Unit dictated by 
            `source_unit`.
          unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
            $\frac{\text{energy}}{\text{area}}$
        sink_use_equals:
          default: .nan
          resample_method: sum
          title: Required sink use.
          description: Required amount of carrier removal from the system (e.g.,
            electricity demand, transport distance). Unit dictated by 
            `source_unit`.
          unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
            $\frac{\text{energy}}{\text{area}}$
        source_eff:
          default: 1.0
          resample_method: mean
          title: Source inflow efficiency
          description: Conversion efficiency from the technology from `source`. 
            Set as value between 1 (no loss) and 0 (all lost).
          unit: unitless.
        source_use_min:
          default: 0
          resample_method: sum
          title: Minimum bound on source.
          description: Minimum source use to add a carrier from the system 
            (e.g., biofuel, coal, rainfall, wind flow). Unit dictated by 
            `source_unit`.
          unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
            $\frac{\text{energy}}{\text{area}}$
        source_use_max:
          default: .inf
          resample_method: sum
          title: Maximum bound on sink.
          description: Maximum sink use to remove a carrier from the system 
            (e.g., biofuel, coal, rainfall, wind flow). Unit dictated by 
            `source_unit`.
          unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
            $\frac{\text{energy}}{\text{area}}$
        source_use_equals:
          default: .nan
          resample_method: sum
          title: Required sink use.
          description: Required amount of carrier removal from the system (e.g.,
            biofuel, coal, rainfall, wind flow). Unit dictated by `source_unit`.
          unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
            $\frac{\text{energy}}{\text{area}}$
        source_cap_max:
          default: .inf
          resample_method: mean
          title: Maximum installed source consumption capacity.
          description: Upper limit on `source_cap` decision variable.
          unit: power.
        source_cap_min:
          default: 0
          resample_method: mean
          title: Minimum installed source consumption capacity
          description: Lower limit on `source_cap` decision variable.
          unit: power.
        storage_cap_max:
          default: .inf
          title: Maximum storage capacity.
          description: Limit upper bound of `storage_cap` decision variable.
          unit: energy.
        storage_cap_min:
          default: 0
          title: Minimum storage capacity.
          description: Limit lower bound of `storage_cap` decision variable.
          unit: energy.
        storage_cap_per_unit:
          default: .inf
          title: Storage capacity per purchased unit.
          description: Set the storage capacity of each integer unit of a 
            technology purchased.
          unit: $\frac{\text{energy}}{\text{unit}}$
        storage_discharge_depth:
          default: 0
          resample_method: mean
          title: Storage depth of discharge.
          description: Defines the minimum level of storage state of charge, as 
            a fraction of total storage capacity.
          unit: unitless.
        storage_initial:
          default: 0
          title: Initial storage level.
          description: Set stored flow in device at the first timestep, as a 
            fraction of total storage capacity.
          unit: unitless.
        storage_loss:
          default: 0
          resample_method: mean
          title: Storage loss rate
          description: Rate of storage loss per hour, used to calculate lost 
            stored flow as `(1 - storage_loss)^hours_per_timestep`.
          unit: $\frac{\text{1}}{\text{hour}}$
        timestep_resolution:
          default: 1
          resample_method: sum
          title: Resolution per timestep.
          unit: hours.
        timestep_weights:
          default: 1
          resample_method: mean
          title: Weight per timestep.
          unit: unitless.
      lookups:
        base_tech:
          dtype: string
          one_of:
          - demand
          - supply
          - conversion
          - storage
          - transmission
          title: Abstract base technology name.
          description: Should be the name of one of the abstract base classes, 
            from which some initial parameter defaults will be derived and with 
            which certain base math will be triggered.
        carrier_in:
          description: Carrier(s) consumed by this technology. Only 
            `transmission`, `conversion`, `storage`, and `demand` technologies 
            can define this parameter
          dtype: bool
          pivot_values_to_dim: carriers
          default: false
        carrier_out:
          description: Carrier(s) produced by this technology. Only 
            `transmission`, `conversion`, `storage`, and `supply` technologies 
            can define this parameter
          dtype: bool
          default: false
          pivot_values_to_dim: carriers
        carrier_export:
          description: Carrier(s) produced by this technology that can be 
            exported out of the system boundaries without having to go to a 
            pre-defined `sink` (i.e., via a `demand` technology). Must be a 
            subset of `carrier_out`.
          dtype: bool
          default: false
          pivot_values_to_dim: carriers
        cap_method:
          dtype: string
          default: continuous
          title: Capacity method switch.
          description: One of 'continuous' (LP model) or 'integer' 
            (integer/binary unit capacity).
          one_of:
          - continuous
          - integer
        cluster_first_timestep:
          dtype: bool
          default: false
          title: Cluster first timestep.
          description: If true, the timestep is the first in the given clustered
            day.
        definition_matrix:
          dtype: bool
          default: false
          description: Whether a technology is defined with particular carriers 
            and at a particular node.
        integer_dispatch:
          dtype: bool
          default: false
          title: Integer dispatch switch.
          description: "When true, will limit per-timestep out/inflows relative to
            the number of units of a technology that are in operation.\nRequires `cap_method=integer`.\n"
        include_storage:
          dtype: bool
          default: false
          title: Storage method switch.
          description: When true, math will be triggered to allow discontinuous 
            carrier inflow and outflows across timesteps.
        force_async_flow:
          dtype: bool
          default: false
          title: Force asynchronous out/inflow.
          description: If True, non-zero `flow_out` and `flow_in` cannot both 
            occur in the same timestep.
        cyclic_storage:
          dtype: bool
          default: true
          title: Cyclic storage switch.
          description: "If true, link storage levels in the last model timestep with
            the first model timestep. `inter_cluster_storage` custom math must be
            included if using time clustering and setting this to `true`. This must
            be set to `false` if using `operate` mode.\n"
        sink_unit:
          dtype: string
          default: absolute
          title: Sink unit
          description: 'Sets the unit of `Sink` to either `absolute` (unit: `energy`),
            `per_area` (unit: `energy/area`), or `per_cap` (unit: `energy/power`).
            `per_area` uses the `area_use` decision variable to scale the sink while
            `per_cap` uses the `flow_cap` decision variable.'
          one_of:
          - absolute
          - per_area
          - per_cap
        source_unit:
          dtype: string
          default: absolute
          title: Source unit
          description: 'Sets the unit of `Source` to either `absolute` (unit: `energy`),
            `per_area` (unit: `energy/area`), or `per_cap` (unit: `energy/power`).
            `per_area` uses the `area_use` decision variable to scale the source while
            `per_cap` uses the `flow_cap` decision variable.'
          one_of:
          - absolute
          - per_area
          - per_cap
        source_cap_equals_flow_cap:
          dtype: bool
          default: false
          title: Source capacity equals flow capacity.
          description: If true, the decision variables `source_cap` and 
            `flow_cap` are forced to equal one another.
        one_way:
          dtype: bool
          default: false
          title: One way transmission.
          description: Forces a transmission technology to only move flow in one
            direction on the link, i.e. from `from` to `to`.
        lookup_cluster_last_timestep:
          description: The last timestep of each cluster.
          dtype: datetime
          resample_method: first
        latitude:
          title: Latitude (WGS84 / EPSG4326).
          dtype: float
          resample_method: mean
        longitude:
          title: Longitude (WGS84 / EPSG4326).
          dtype: float
          resample_method: mean
      constraints:
        flow_capacity_per_storage_capacity_min:
          description: Set the lower bound of storage flow capacity relative to 
            its storage capacity.
          foreach:
          - nodes
          - techs
          - carriers
          where: storage_cap AND flow_cap_per_storage_cap_min
          equations:
          - expression: flow_cap >= storage_cap * flow_cap_per_storage_cap_min
        flow_capacity_per_storage_capacity_max:
          description: Set the upper bound of storage flow capacity relative to 
            its storage capacity.
          foreach:
          - nodes
          - techs
          - carriers
          where: storage_cap AND flow_cap_per_storage_cap_max
          equations:
          - expression: flow_cap <= storage_cap * flow_cap_per_storage_cap_max
        source_capacity_equals_flow_capacity:
          description: Set a `supply` technology's flow capacity to equal its 
            source capacity.
          foreach:
          - nodes
          - techs
          - carriers
          where: source_cap AND source_cap_equals_flow_cap==True
          equations:
          - expression: source_cap == flow_cap
        force_zero_area_use:
          description: Set a technology's area use to zero if its flow capacity 
            upper bound is zero.
          foreach:
          - nodes
          - techs
          where: area_use AND flow_cap_max==0
          equations:
          - expression: area_use == 0
        area_use_per_flow_capacity:
          description: Set a fixed relationship between a technology's flow 
            capacity and its area use.
          foreach:
          - nodes
          - techs
          - carriers
          where: area_use AND area_use_per_flow_cap
          equations:
          - expression: area_use == flow_cap * area_use_per_flow_cap
        area_use_capacity_per_loc:
          description: Set an upper bound on the total area that all 
            technologies with `area_use` can occupy at a given node.
          foreach:
          - nodes
          where: area_use AND available_area
          equations:
          - expression: sum(area_use, over=techs) <= available_area
        flow_capacity_systemwide_max:
          description: Set an upper bound on flow capacity of a technology 
            across all nodes in which the technology exists.
          foreach:
          - techs
          - carriers
          where: flow_cap_max_systemwide
          equations:
          - expression: sum(flow_cap, over=nodes) <= flow_cap_max_systemwide
        flow_capacity_systemwide_min:
          description: Set a lower bound on flow capacity of a technology across
            all nodes in which the technology exists.
          foreach:
          - techs
          - carriers
          where: flow_cap_min_systemwide
          equations:
          - expression: sum(flow_cap, over=nodes) >= flow_cap_min_systemwide
        balance_conversion:
          description: Fix the relationship between a `conversion` technology's 
            outflow and consumption.
          foreach:
          - nodes
          - techs
          - timesteps
          where: base_tech==conversion AND NOT include_storage==true
          equations:
          - expression: sum(flow_out_inc_eff, over=carriers) == 
              sum(flow_in_inc_eff, over=carriers)
        flow_out_max:
          description: Set the upper bound of a technology's outflow.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: carrier_out
          equations:
          - expression: flow_out <= flow_cap * timestep_resolution * 
              flow_out_parasitic_eff
        flow_out_min:
          description: Set the lower bound of a technology's outflow.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_out_min_relative
          equations:
          - expression: flow_out >= flow_cap * timestep_resolution * 
              flow_out_min_relative
        flow_in_max:
          description: Set the upper bound of a technology's inflow.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: carrier_in
          equations:
          - expression: flow_in <= flow_cap * timestep_resolution
        source_max:
          description: Set the upper bound of a `supply` technology's source 
            consumption.
          foreach:
          - nodes
          - techs
          - timesteps
          where: source_cap
          equations:
          - expression: source_use <= timestep_resolution * source_cap
        storage_max:
          description: Set the upper bound of the amount of carrier a technology
            can store.
          foreach:
          - nodes
          - techs
          - timesteps
          where: storage
          equations:
          - expression: storage <= storage_cap
        storage_discharge_depth_limit:
          description: Set the lower bound of the stored carrier a technology 
            must keep in reserve at all times.
          foreach:
          - nodes
          - techs
          - timesteps
          where: storage AND storage_discharge_depth
          equations:
          - expression: storage - storage_discharge_depth * storage_cap >= 0
        system_balance:
          description: Set the global carrier balance of the optimisation 
            problem by fixing the total production of a given carrier to equal 
            the total consumption of that carrier at every node in every 
            timestep.
          foreach:
          - nodes
          - carriers
          - timesteps
          equations:
          - expression: sum(flow_out, over=techs) - sum(flow_in, over=techs) - 
              $flow_export + $unmet_demand_and_unused_supply == 0
          sub_expressions:
            flow_export:
            - where: any(carrier_export, over=techs)
              expression: sum(flow_export, over=techs)
            - where: NOT any(carrier_export, over=techs)
              expression: '0'
            unmet_demand_and_unused_supply:
            - where: config.ensure_feasibility==True
              expression: unmet_demand + unused_supply
            - where: NOT config.ensure_feasibility==True
              expression: '0'
        balance_demand:
          description: Set the upper bound on, or a fixed total of, that a 
            demand technology must dump to its sink in each timestep.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: base_tech==demand
          equations:
          - where: sink_use_equals
            expression: flow_in_inc_eff == sink_use_equals * $sink_scaler
          - where: NOT sink_use_equals AND sink_use_max
            expression: flow_in_inc_eff <= sink_use_max * $sink_scaler
          sub_expressions:
            sink_scaler:
            - where: sink_unit==per_area
              expression: area_use
            - where: sink_unit==per_cap
              expression: sum(flow_cap, over=carriers)
            - where: sink_unit==absolute
              expression: '1'
        balance_demand_min_use:
          description: Set the lower bound on the quantity of flow a `demand` 
            technology must dump to its sink in each timestep.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: sink_use_min AND NOT sink_use_equals AND base_tech==demand
          equations:
          - expression: flow_in_inc_eff >= sink_use_min * $sink_scaler
          sub_expressions:
            sink_scaler:
            - where: sink_unit==per_area
              expression: area_use
            - where: sink_unit==per_cap
              expression: sum(flow_cap, over=carriers)
            - where: sink_unit==absolute
              expression: '1'
        balance_supply_no_storage:
          description: Fix the outflow of a `supply` technology to its 
            consumption of the available source.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: base_tech==supply AND NOT include_storage==True
          equations:
          - expression: flow_out_inc_eff == source_use * source_eff
        balance_supply_with_storage:
          description: Fix the outflow of a `supply` technology to its 
            consumption of the available source, with a storage buffer to 
            temporally offset the outflow from source consumption.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: storage AND base_tech==supply
          equations:
          - expression: storage == $storage_previous_step + source_use * 
              source_eff - flow_out_inc_eff
          sub_expressions:
            storage_previous_step:
            - where: timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True
              expression: storage_initial * storage_cap
            - where: "(\n  (timesteps==get_val_at_index(timesteps=0) AND cyclic_storage==True)\n\
                \  OR NOT timesteps==get_val_at_index(timesteps=0)\n) AND NOT cluster_first_timestep==True"
              expression: (1 - storage_loss) ** roll(timestep_resolution, 
                timesteps=1) * roll(storage, timesteps=1)
            - where: cluster_first_timestep==True AND NOT 
                (timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True)
              expression: (1 - storage_loss) ** 
                select_from_lookup_arrays(timestep_resolution, 
                timesteps=lookup_cluster_last_timestep) * 
                select_from_lookup_arrays(storage, 
                timesteps=lookup_cluster_last_timestep)
        source_availability_supply:
          description: Set the upper bound on, or a fixed total of, a `supply` 
            technology's ability to consume its available resource.
          foreach:
          - nodes
          - techs
          - timesteps
          where: source_use AND (source_use_equals OR source_use_max)
          equations:
          - where: source_use_equals
            expression: source_use == source_use_equals * $source_scaler
          - where: NOT source_use_equals AND source_use_max
            expression: source_use <= source_use_max * $source_scaler
          sub_expressions:
            source_scaler:
            - where: source_unit==per_area
              expression: area_use
            - where: source_unit==per_cap
              expression: sum(flow_cap, over=carriers)
            - where: source_unit==absolute
              expression: '1'
        balance_supply_min_use:
          description: Set the lower bound on the quantity of its source a 
            `supply` technology must use in each timestep.
          foreach:
          - nodes
          - techs
          - timesteps
          where: source_use_min AND NOT source_use_equals AND base_tech==supply
          equations:
          - expression: source_use >= source_use_min * $source_scaler
          sub_expressions:
            source_scaler:
            - where: source_unit==per_area
              expression: area_use
            - where: source_unit==per_cap
              expression: sum(flow_cap, over=carriers)
            - where: source_unit==absolute
              expression: '1'
        balance_storage:
          description: Fix the quantity of carrier stored in a `storage` 
            technology at the end of each timestep based on the net flow of 
            carrier charged and discharged and the quantity of carrier stored at
            the start of the timestep.
          foreach:
          - nodes
          - techs
          - timesteps
          where: (include_storage==true or base_tech==storage) AND NOT 
            (base_tech==supply OR base_tech==demand)
          equations:
          - expression: "storage == $storage_previous_step -\n  sum(flow_out_inc_eff,
              over=carriers) + sum(flow_in_inc_eff, over=carriers)"
          sub_expressions:
            storage_previous_step:
            - where: timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True
              expression: storage_initial * storage_cap
            - where: "(\n  (timesteps==get_val_at_index(timesteps=0) AND cyclic_storage==True)\n\
                \  OR NOT timesteps==get_val_at_index(timesteps=0)\n) AND NOT cluster_first_timestep==True"
              expression: (1 - storage_loss) ** roll(timestep_resolution, 
                timesteps=1) * roll(storage, timesteps=1)
            - where: cluster_first_timestep==True AND NOT 
                (timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True)
              expression: (1 - storage_loss) ** 
                select_from_lookup_arrays(timestep_resolution, 
                timesteps=lookup_cluster_last_timestep) * 
                select_from_lookup_arrays(storage, 
                timesteps=lookup_cluster_last_timestep)
        set_storage_initial:
          description: Fix the relationship between carrier stored in a 
            `storage` technology at the start and end of the whole model period.
          foreach:
          - nodes
          - techs
          where: storage AND storage_initial AND cyclic_storage==True
          equations:
          - expression: "storage[timesteps=$final_step] * (\n  (1 - storage_loss)
              ** timestep_resolution[timesteps=$final_step]\n) == storage_initial
              * storage_cap"
          slices:
            final_step:
            - expression: get_val_at_index(timesteps=-1)
          active: true
        balance_transmission:
          description: Fix the relationship between between carrier flowing into
            and out of a `transmission` link in each timestep.
          foreach:
          - techs
          - timesteps
          where: base_tech==transmission
          equations:
          - expression: sum(flow_out_inc_eff, over=[nodes, carriers]) == 
              sum(flow_in_inc_eff, over=[nodes, carriers])
        symmetric_transmission:
          description: Fix the flow capacity of two `transmission` technologies 
            representing the same link in the system.
          foreach:
          - nodes
          - techs
          where: base_tech==transmission
          equations:
          - expression: sum(flow_cap, over=carriers) == link_flow_cap
        export_balance:
          description: Set the lower bound of a technology's outflow to a 
            technology's carrier export, for any technologies that can export 
            carriers out of the system.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_export
          equations:
          - expression: flow_out >= flow_export
        ramping_up:
          description: Set the upper bound on a technology's ability to ramp 
            outflow up beyond a certain percentage compared to the previous 
            timestep.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_ramping AND NOT timesteps==get_val_at_index(timesteps=0)
          equations:
          - expression: $flow - roll($flow, timesteps=1) <= flow_ramping * 
              flow_cap
          sub_expressions:
            flow:
            - where: carrier_out AND NOT carrier_in
              expression: flow_out / timestep_resolution
            - where: carrier_in AND NOT carrier_out
              expression: flow_in / timestep_resolution
            - where: carrier_in AND carrier_out
              expression: (flow_out - flow_in) / timestep_resolution
        ramping_down:
          description: Set the upper bound on a technology's ability to ramp 
            outflow down beyond a certain percentage compared to the previous 
            timestep.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_ramping AND NOT timesteps==get_val_at_index(timesteps=0)
          equations:
          - expression: -1 * flow_ramping * flow_cap <= $flow - roll($flow, 
              timesteps=1)
          sub_expressions:
            flow:
            - where: carrier_out AND NOT carrier_in
              expression: flow_out / timestep_resolution
            - where: carrier_in AND NOT carrier_out
              expression: flow_in / timestep_resolution
            - where: carrier_in AND carrier_out
              expression: (flow_out - flow_in) / timestep_resolution
      variables:
        flow_cap:
          title: Technology flow (a.k.a. nominal) capacity
          description: A technology's flow capacity, also known as its nominal 
            or nameplate capacity.
          default: 0
          unit: power
          foreach:
          - nodes
          - techs
          - carriers
          bounds:
            min: flow_cap_min
            max: flow_cap_max
        link_flow_cap:
          title: Link flow capacity
          description: A transmission technology's flow capacity, also known as 
            its nominal or nameplate capacity.
          default: 0
          unit: power
          foreach:
          - techs
          where: base_tech==transmission
          bounds:
            min: 0
            max: .inf
        flow_out:
          title: Carrier outflow
          description: The outflow of a technology per timestep, also known as 
            the flow discharged (from `storage` technologies) or the flow 
            received (by `transmission` technologies) on a link.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: carrier_out
          bounds:
            min: 0
            max: .inf
        flow_in:
          title: Carrier inflow
          description: The inflow to a technology per timestep, also known as 
            the flow consumed (by `storage` technologies) or the flow sent (by 
            `transmission` technologies) on a link.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: carrier_in
          bounds:
            min: 0
            max: .inf
        flow_export:
          title: Carrier export
          description: The flow of a carrier exported outside the system 
            boundaries by a technology per timestep.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: carrier_export
          bounds:
            min: export_min
            max: export_max
        area_use:
          title: Area utilisation
          description: The area in space utilised directly (e.g., solar PV 
            panels) or indirectly (e.g., biofuel crops) by a technology.
          default: 0
          unit: area
          foreach:
          - nodes
          - techs
          where: (area_use_min OR area_use_max OR area_use_per_flow_cap OR 
            sink_unit==per_area OR source_unit==per_area)
          bounds:
            min: area_use_min
            max: area_use_max
        source_use:
          title: Source flow use
          description: The carrier flow consumed from outside the system 
            boundaries by a `supply` technology.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - timesteps
          where: base_tech==supply
          bounds:
            min: 0
            max: .inf
        source_cap:
          title: Source flow capacity
          description: The upper limit on a flow that can be consumed from 
            outside the system boundaries by a `supply` technology in each 
            timestep.
          default: 0
          unit: power
          foreach:
          - nodes
          - techs
          where: base_tech==supply
          bounds:
            min: source_cap_min
            max: source_cap_max
        storage_cap:
          title: Stored carrier capacity
          description: The upper limit on a carrier that can be stored by a 
            technology in any timestep.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          where: include_storage==True OR base_tech==storage
          domain: real
          bounds:
            min: storage_cap_min
            max: storage_cap_max
          active: true
        storage:
          title: Stored carrier
          description: The carrier stored by a `storage` technology in each 
            timestep.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - timesteps
          where: include_storage==True OR base_tech==storage
          bounds:
            min: 0
            max: .inf
        unmet_demand:
          title: Unmet demand (load shedding)
          description: Virtual source of carrier flow to ensure model 
            feasibility. This should only be considered a debugging rather than 
            a modelling tool as it may distort the model in other ways due to 
            the large impact it has on the objective function value. When 
            present in a model in which it has been requested, it indicates an 
            inability for technologies in the model to reach a sufficient 
            combined supply capacity to meet demand.
          default: 0
          unit: energy
          foreach:
          - nodes
          - carriers
          - timesteps
          where: config.ensure_feasibility==True
          bounds:
            min: 0
            max: .inf
        unused_supply:
          title: Unused supply (curtailment)
          description: 'Virtual sink of carrier flow to ensure model feasibility.
            This should only be considered a debugging rather than a modelling tool
            as it may distort the model in other ways due to the large impact it has
            on the objective function value. In model results, the negation of this
            variable is combined with `unmet_demand` and presented as only one variable:
            `unmet_demand`. When present in a model in which it has been requested,
            it indicates an inability for technologies in the model to reach a sufficient
            combined consumption capacity to meet required outflow (e.g. from renewables
            without the possibility of curtailment).'
          default: 0
          unit: energy
          foreach:
          - nodes
          - carriers
          - timesteps
          where: config.ensure_feasibility==True
          bounds:
            min: -.inf
            max: 0
      objectives:
        min_cost_optimisation:
          description: Minimise the total cost of installing and operating all 
            technologies in the system. If multiple cost classes are present 
            (e.g., monetary and co2 emissions), the weighted sum of total costs 
            is minimised. Cost class weights can be defined in the indexed 
            parameter `objective_cost_weights`.
          equations:
          - where: any(cost, over=[nodes, techs, costs])
            expression: "sum(\n  sum(cost, over=[nodes, techs])\n  * objective_cost_weights,\n\
              \  over=costs\n) + $unmet_demand"
          - where: NOT any(cost, over=[nodes, techs, costs])
            expression: $unmet_demand
          sub_expressions:
            unmet_demand:
            - where: config.ensure_feasibility==True
              expression: "sum(\n  sum(unmet_demand - unused_supply, over=[carriers,
                nodes])\n  * timestep_weights,\n  over=timesteps\n) * bigM"
            - where: NOT config.ensure_feasibility==True
              expression: '0'
          sense: minimise
          active: true
      global_expressions:
        flow_out_inc_eff:
          title: Carrier outflow including losses
          description: Outflows after taking efficiency losses into account.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_out
          equations:
          - where: base_tech==transmission
            expression: "flow_out / (\n  flow_out_eff * flow_out_parasitic_eff *\n\
              \  flow_out_eff_per_distance ** distance\n)"
          - where: NOT base_tech==transmission
            expression: flow_out / (flow_out_eff * flow_out_parasitic_eff)
        flow_in_inc_eff:
          title: Carrier inflow including losses
          description: Inflows after taking efficiency losses into account.
          default: 0
          unit: energy
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_in
          equations:
          - where: base_tech==transmission
            expression: flow_in * flow_in_eff * flow_in_eff_per_distance ** 
              distance
          - where: NOT base_tech==transmission
            expression: flow_in * flow_in_eff
        cost_operation_variable:
          title: Variable operating costs
          description: The operating costs per timestep of a technology.
          default: 0
          unit: $\frac{\text{cost}}{\text{hour}}$
          foreach:
          - nodes
          - techs
          - costs
          - timesteps
          where: cost_export OR cost_flow_in OR cost_flow_out
          equations:
          - expression: timestep_weights * ($cost_export + $cost_flow_out + 
              $cost_flow_in)
          sub_expressions:
            cost_export:
            - where: any(carrier_export, over=carriers) AND any(cost_export, 
                over=carriers)
              expression: sum(cost_export * flow_export, over=carriers)
            - where: NOT (any(carrier_export, over=carriers) AND 
                any(cost_export, over=carriers))
              expression: '0'
            cost_flow_in:
            - where: base_tech==supply
              expression: cost_flow_in * source_use
            - where: NOT base_tech==supply
              expression: sum(cost_flow_in * flow_in, over=carriers)
            cost_flow_out:
            - expression: sum(cost_flow_out * flow_out, over=carriers)
        cost_investment_flow_cap:
          title: Flow capacity investment costs
          description: The investment costs associated with the nominal/rated 
            capacity of a technology.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - carriers
          - costs
          where: flow_cap AND (cost_flow_cap OR cost_flow_cap_per_distance)
          equations:
          - expression: $cost_sum * flow_cap
          sub_expressions:
            cost_sum:
            - where: base_tech==transmission
              expression: (cost_flow_cap + cost_flow_cap_per_distance * 
                distance) * 0.5
            - where: NOT base_tech==transmission
              expression: cost_flow_cap
        cost_investment_storage_cap:
          title: Storage capacity investment costs
          description: The investment costs associated with the storage capacity
            of a technology.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_storage_cap AND storage_cap
          equations:
          - expression: cost_storage_cap * storage_cap
        cost_investment_source_cap:
          title: Source flow capacity investment costs
          description: The investment costs associated with the source 
            consumption capacity of a technology.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_source_cap AND source_cap
          equations:
          - expression: cost_source_cap * source_cap
        cost_investment_area_use:
          title: Area utilisation investment costs
          description: The investment costs associated with the area used by a 
            technology.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_area_use AND area_use
          equations:
          - expression: cost_area_use * area_use
        cost_investment:
          title: Total investment costs
          description: The installation costs of a technology, including those 
            linked to the nameplate capacity, land use, and storage size.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_investment_flow_cap OR cost_investment_storage_cap OR 
            cost_investment_source_cap OR cost_investment_area_use
          equations:
          - expression: sum(cost_investment_flow_cap, over=carriers) + 
              cost_investment_storage_cap + cost_investment_source_cap + 
              cost_investment_area_use
        cost_investment_annualised:
          title: Equivalent annual investment costs
          description: An annuity factor has been applied to scale lifetime 
            investment costs to annual values that can be directly compared to 
            operation costs. If the modeling period is not equal to one full 
            year, this will be scaled accordingly.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_investment
          equations:
          - expression: $annualisation_weight * $depreciation_rate * 
              cost_investment
          sub_expressions:
            annualisation_weight:
            - expression: sum(timestep_resolution * timestep_weights, 
                over=timesteps) / 8760
            depreciation_rate:
            - where: cost_depreciation_rate
              expression: cost_depreciation_rate
            - where: NOT cost_depreciation_rate AND cost_interest_rate==0
              expression: 1 / lifetime
            - where: NOT cost_depreciation_rate AND cost_interest_rate>0
              expression: (cost_interest_rate * ((1 + cost_interest_rate) ** 
                lifetime)) / (((1 + cost_interest_rate) ** lifetime) - 1)
        cost_operation_fixed:
          title: Total fixed operation costs
          description: The fixed, annual operation costs of a technology, which 
            are calculated relative to investment costs. If the modeling period 
            is not equal to one full year, this will be scaled accordingly.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_investment AND (cost_om_annual OR 
            cost_om_annual_investment_fraction)
          equations:
          - expression: "$annualisation_weight * (\n  sum(cost_om_annual * flow_cap,
              over=carriers) +\n  cost_investment * cost_om_annual_investment_fraction\n\
              )"
          sub_expressions:
            annualisation_weight:
            - expression: sum(timestep_resolution * timestep_weights, 
                over=timesteps) / 8760
        cost:
          title: Total costs
          description: The total annualised costs of a technology, including 
            installation and operation costs.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_investment_annualised OR cost_operation_variable OR 
            cost_operation_fixed
          equations:
          - expression: cost_investment_annualised + $cost_operation_sum + 
              cost_operation_fixed
          sub_expressions:
            cost_operation_sum:
            - where: cost_operation_variable
              expression: sum(cost_operation_variable, over=timesteps)
            - where: NOT cost_operation_variable
              expression: '0'
          active: true
      piecewise_constraints: {}
      checks:
        must_have_base:
          where: not base_tech
          message: An abstract `base_tech` must be defined for every technology 
            at every node.
          errors: raise
        distance_only_for_transmission:
          where: not base_tech==transmission and (distance or 
            flow_in_eff_per_distance or flow_out_eff_per_distance or 
            cost_flow_cap_per_distance or cost_purchase_per_distance)
          message: Only transmission technologies can define `distance` or 
            `..._per_distance`.
          errors: raise
        unbounded_flow_cap_cost:
          where: cost_flow_cap<0 AND not flow_cap_max
          message: Cannot have a negative `cost_flow_cap` as there is an unset 
            corresponding `flow_cap_max` constraint
          errors: raise
        unbounded_storage_cap_cost:
          where: cost_storage_cap<0 AND not storage_cap_max
          message: Cannot have a negative `cost_storage_cap` as there is an 
            unset corresponding `storage_cap_max` constraint
          errors: raise
        unbounded_area_use_cost:
          where: cost_area_use<0 AND not area_use_max
          message: Cannot have a negative `cost_area_use` as there is an unset 
            corresponding `area_use_max` constraint
          errors: raise
        unbounded_source_use_cost:
          where: cost_source_cap<0 AND not source_use_max
          message: Cannot have a negative `cost_source_cap` as there is an unset
            corresponding `source_use_max` constraint
          errors: raise
        finite_source_use:
          where: source_use_equals==inf or sink_use_equals==inf
          message: Cannot include infinite values in 
            `source_use_equals`/`sink_use_equals`
          errors: raise
        all_or_nothing_lat_lon:
          where: (any(latitude, over=nodes) or any(longitude, over=nodes)) and 
            not (latitude or longitude)
          message: Must define node latitude and longitude for _all_ nodes or 
            _no_ nodes.
          errors: raise
        export_only_for_outflows:
          where: carrier_export and not any(carrier_out, over=nodes)
          message: Export carriers must be one of the technology outflow 
            carriers.
          errors: raise
        storage_initial_max:
          where: storage_initial and (storage_initial<0 OR storage_initial>1)
          message: storage_initial is a fraction, requiring values within the 
            interval [0, 1].
          errors: raise
        unit_commitment_only_for_units:
          where: integer_dispatch==True AND NOT cap_method==integer
          message: Cannot use the integer `integer_dispatch` unless the 
            technology is using an integer unit capacities 
            (`cap_method=integer`).
          errors: raise
        conflicting_flow_caps:
          where: (flow_cap_max OR flow_cap_min) AND flow_cap_per_unit
          message: Cannot define both `flow_cap_per_unit` and 
            `flow_cap_max`/`flow_cap_min`
          errors: raise
        conflicting_storage_caps:
          where: (storage_cap_max OR storage_cap_min) AND storage_cap_per_unit
          message: Cannot define both `storage_cap_per_unit` and 
            `storage_cap_max`/`storage_cap_min`
          errors: raise
        lat_lons_out_of_range:
          where: latitude < -90 OR latitude > 90 OR longitude < -180 OR 
            longitude > 180
          message: Node latitude/longitude must be specified in WGS84 / EPSG4326
            format.
          errors: warn
    milp:
      variables:
        purchased_units:
          title: Number of purchased units
          description: "Integer number of a technology that has been purchased, for
            any technology set to require integer capacity purchasing. This is used
            to allow installation of fixed capacity units of technologies ( if `flow_cap_max`
            == `flow_cap_min`) and/or to set a fixed cost for a technology, irrespective
            of its installed capacity. On top of a fixed technology cost, a continuous
            cost for the quantity of installed capacity can still be applied.\nSince
            technology capacity is no longer a continuous decision variable, it is
            possible for these technologies to have a lower bound set on outflow/consumption
            which will only be enforced in those timesteps that the technology is
            operating. Otherwise, the same lower bound forces the technology to produce/consume
            that minimum amount of carrier in *every* timestep."
          default: 0
          unit: integer
          foreach:
          - nodes
          - techs
          where: cap_method==integer
          domain: integer
          bounds:
            min: purchased_units_min
            max: purchased_units_max
        operating_units:
          title: Number of operating units
          description: Integer number of a technology that is operating in each 
            timestep, for any technology set to require integer capacity 
            purchasing.
          default: 0
          unit: integer
          foreach:
          - nodes
          - techs
          - timesteps
          where: integer_dispatch==True AND cap_method==integer
          domain: integer
          bounds:
            min: 0
            max: .inf
        async_flow_switch:
          title: Asynchronous carrier flow switch
          description: Binary switch to force asynchronous outflow/consumption 
            of technologies with both `flow_in` and `flow_out` defined. This 
            ensures that a technology with carrier flow efficiencies < 100% 
            cannot produce and consume a flow simultaneously to remove unwanted 
            carrier from the system.
          default: 0
          unit: integer
          foreach:
          - nodes
          - techs
          - timesteps
          where: force_async_flow==True
          domain: integer
          bounds:
            min: 0
            max: 1
        available_flow_cap:
          title: Available carrier flow capacity
          description: Flow capacity that will be set to zero if the technology 
            is not operating in a given timestep and will be set to the value of
            the decision variable `flow_cap` otherwise. This is useful when you 
            want to set a minimum flow capacity for any technology investment, 
            but also want to allow the model to decide the capacity. It is 
            expected to only be used when `purchased_units_max == 1`, i.e., the 
            `purchased_units` decision variable is binary. If 
            `purchased_units_max > 1`, you may get strange results and should 
            instead use the less flexible `flow_cap_per_unit`.
          default: 0
          unit: power
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: integer_dispatch==True AND flow_cap_max AND NOT 
            flow_cap_per_unit
          bounds:
            min: 0
            max: .inf
        flow_cap:
          description: A technology's flow capacity, also known as its nominal 
            or nameplate capacity. Minimum is set to 0 and handled in a distinct
            constraint to handle the integer purchase variable.
          bounds:
            min: 0
        area_use:
          description: The area in space utilised directly (e.g., solar PV 
            panels) or indirectly (e.g., biofuel crops) by a technology. Minimum
            is set to 0 and handled in a distinct constraint to handle the 
            integer purchase variable.
          bounds:
            min: 0
        source_cap:
          description: The upper limit on a flow that can be consumed from 
            outside the system boundaries by a `supply` technology in each 
            timestep. Minimum is set to 0 and handled in a distinct constraint 
            to handle the integer purchase variable.
          bounds:
            min: 0
        storage_cap:
          description: The upper limit on a carrier that can be stored by a 
            technology in any timestep. Minimum is set to 0 and handled in a 
            distinct constraint to handle the integer purchase variable.
          bounds:
            min: 0
      constraints:
        unit_commitment_milp:
          description: Set the upper bound of the number of integer units of 
            technology that can exist, for any technology using integer units to
            define its capacity.
          foreach:
          - nodes
          - techs
          - timesteps
          where: operating_units AND purchased_units
          equations:
          - expression: operating_units <= purchased_units
        flow_out_max_milp:
          description: Set the upper bound of a technology's ability to produce 
            carriers, for any technology using integer units to define its 
            capacity.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_out AND operating_units AND flow_cap_per_unit
          equations:
          - expression: flow_out <= operating_units * timestep_resolution * 
              flow_cap_per_unit * flow_out_parasitic_eff
        flow_in_max_milp:
          description: Set the upper bound of a technology's ability to consume 
            carriers, for any technology using integer units to define its 
            capacity.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_in AND operating_units AND flow_cap_per_unit
          equations:
          - expression: flow_in <= operating_units * timestep_resolution * 
              flow_cap_per_unit
        flow_out_min_milp:
          description: Set the lower bound of a technology's ability to produce 
            carriers, for any technology using integer units to define its 
            capacity.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: flow_out AND operating_units AND flow_out_min_relative
          equations:
          - where: flow_cap_per_unit
            expression: flow_out >= operating_units * timestep_resolution * 
              flow_cap_per_unit * flow_out_min_relative
          - where: available_flow_cap
            expression: flow_out >= available_flow_cap * timestep_resolution * 
              flow_out_min_relative
        storage_capacity_units_milp:
          description: Fix the storage capacity of any technology using integer 
            units to define its capacity.
          foreach:
          - nodes
          - techs
          where: storage AND purchased_units AND storage_cap_per_unit
          equations:
          - expression: storage_cap == purchased_units * storage_cap_per_unit
        flow_capacity_units_milp:
          description: Fix the flow capacity of any technology using integer 
            units to define its capacity.
          foreach:
          - nodes
          - techs
          - carriers
          where: purchased_units AND flow_cap_per_unit
          equations:
          - expression: flow_cap == purchased_units * flow_cap_per_unit
        flow_capacity_max_purchase_milp:
          description: Set the upper bound on a technology's flow capacity, for 
            any technology with integer capacity purchasing.
          foreach:
          - nodes
          - techs
          - carriers
          where: purchased_units
          equations:
          - where: flow_cap_max
            expression: flow_cap <= flow_cap_max * purchased_units
          - where: NOT flow_cap_max
            expression: flow_cap <= bigM * purchased_units
        storage_capacity_max_purchase_milp:
          description: Set the upper bound on a technology's storage capacity, 
            for any technology with integer capacity purchasing.
          foreach:
          - nodes
          - techs
          where: purchased_units AND storage_cap_max
          equations:
          - expression: storage_cap <= storage_cap_max * purchased_units
        unit_capacity_max_systemwide_milp:
          description: Set the upper bound on the total number of units of a 
            technology that can be purchased across all nodes where the 
            technology can exist, for any technology using integer units to 
            define its capacity.
          foreach:
          - techs
          where: purchased_units AND purchased_units_max_systemwide
          equations:
          - expression: sum(purchased_units, over=nodes) <= 
              purchased_units_max_systemwide
        unit_capacity_min_systemwide_milp:
          description: Set the lower bound on the total number of units of a 
            technology that can be purchased across all nodes where the 
            technology can exist, for any technology using integer units to 
            define its capacity.
          foreach:
          - techs
          where: purchased_units AND purchased_units_max_systemwide
          equations:
          - expression: sum(purchased_units, over=nodes) >= 
              purchased_units_min_systemwide
        async_flow_in_milp:
          description: Set a technology's ability to have inflow in the same 
            timestep that it has outflow, for any technology using the 
            asynchronous flow binary switch.
          foreach:
          - nodes
          - techs
          - timesteps
          where: async_flow_switch
          equations:
          - expression: sum(flow_in, over=carriers) <= (1 - async_flow_switch) *
              bigM
        async_flow_out_milp:
          description: Set a technology's ability to have outflow in the same 
            timestep that it has inflow, for any technology using the 
            asynchronous flow binary switch.
          foreach:
          - nodes
          - techs
          - timesteps
          where: async_flow_switch
          equations:
          - expression: sum(flow_out, over=carriers) <= async_flow_switch * bigM
        available_flow_cap_continuous:
          description: Limit flow capacity to the value of the `flow_cap` 
            decision variable when the technology is operating in a given 
            timestep.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: available_flow_cap
          equations:
          - expression: available_flow_cap <= flow_cap
        available_flow_cap_binary:
          description: Limit flow capacity to zero if the technology is not 
            operating in a given timestep.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: available_flow_cap
          equations:
          - expression: available_flow_cap <= flow_cap_max * operating_units
        available_flow_cap_max_binary_continuous_switch:
          description: Force flow capacity to equal the value of the `flow_cap` 
            decision variable if the technology is operating in a given 
            timestep, zero otherwise.
          foreach:
          - nodes
          - techs
          - carriers
          - timesteps
          where: available_flow_cap
          equations:
          - expression: available_flow_cap >= flow_cap + ((operating_units - 
              purchased_units) * flow_cap_max)
        flow_capacity_minimum:
          description: Set the lower bound on a technology's flow capacity, for 
            any technology with a non-zero lower bound, with or without integer 
            capacity purchasing.
          foreach:
          - nodes
          - techs
          - carriers
          where: flow_cap_min
          equations:
          - where: NOT purchased_units
            expression: flow_cap >= flow_cap_min
          - where: purchased_units
            expression: flow_cap >= flow_cap_min * purchased_units
        storage_capacity_minimum:
          description: Set the lower bound on a technology's storage capacity 
            for any technology with a non-zero lower bound, with or without 
            integer capacity purchasing.
          foreach:
          - nodes
          - techs
          where: storage_cap_min
          equations:
          - where: NOT purchased_units
            expression: storage_cap >= storage_cap_min
          - where: purchased_units
            expression: storage_cap >= storage_cap_min * purchased_units
        area_use_minimum:
          description: Set the lower bound on a technology's area use for any 
            technology with a non-zero lower bound, with or without integer 
            capacity purchasing.
          foreach:
          - nodes
          - techs
          where: area_use_min
          equations:
          - where: NOT purchased_units
            expression: area_use >= area_use_min
          - where: purchased_units
            expression: area_use >= area_use_min * purchased_units
        source_capacity_minimum:
          description: Set the lower bound on a technology's source capacity for
            any supply technology with a non-zero lower bound, with or without 
            integer capacity purchasing.
          foreach:
          - nodes
          - techs
          where: base_tech==supply AND source_cap_min
          equations:
          - where: NOT purchased_units
            expression: source_cap >= source_cap_min
          - where: purchased_units
            expression: source_cap >= source_cap_min * purchased_units
        flow_out_max:
          description: Set the upper bound of a continuous technology's outflow.
          where: carrier_out AND NOT operating_units
        flow_out_min:
          description: Set the lower bound of a continuous technology's outflow.
          where: flow_out_min_relative AND NOT operating_units
        flow_in_max:
          description: Set the upper bound of a continuous technology's inflow.
          where: carrier_in AND NOT operating_units
      global_expressions:
        cost_investment_purchase:
          title: Binary purchase investment costs
          description: The investment costs associated with the binary purchase 
            of a technology.
          default: 0
          unit: cost
          foreach:
          - nodes
          - techs
          - costs
          where: cost_purchase AND purchased_units
          order: -1
          equations:
          - where: base_tech==transmission
            expression: (cost_purchase + cost_purchase_per_distance * distance) 
              * purchased_units * 0.5
          - where: NOT base_tech==transmission
            expression: cost_purchase * purchased_units
        cost_investment:
          title: Total investment costs
          description: The installation costs of a technology, including those 
            linked to the nameplate capacity, land use, storage size, and 
            binary/integer unit purchase.
          where: cost_investment_flow_cap OR cost_investment_storage_cap OR 
            cost_investment_source_cap OR cost_investment_area_use OR 
            cost_investment_purchase
          equations:
          - expression: sum(cost_investment_flow_cap, over=carriers) + 
              cost_investment_storage_cap + cost_investment_source_cap + 
              cost_investment_area_use + cost_investment_purchase
    operate:
      parameters:
        area_use:
          default: .inf
          title: Area used.
          description: 'Sets `area_use` to a parameter in operate mode. NOTE: this
            parameter cannot be used in `base` mode as it clashes with the decision
            variable of the same name.'
          unit: $\text{area}$.
        storage_cap:
          default: .inf
          title: Rated storage capacity.
          description: 'Sets `storage_cap` to a parameter in operate mode. NOTE: this
            parameter cannot be used in `base` mode as it clashes with the decision
            variable of the same name.'
          unit: $\text{area}$.
        purchased_units:
          default: .inf
          title: Number of purchased units.
          description: 'Sets `purchased_units` to a parameter in operate mode. NOTE:
            this parameter cannot be used in `base` mode as it clashes with the decision
            variable of the same name.'
          unit: integer
        source_cap:
          default: .inf
          title: Installed source consumption capacity.
          description: 'Sets `source_cap` to a parameter in operate mode. NOTE: this
            parameter cannot be used in `base` mode as it clashes with the decision
            variable of the same name.'
          unit: power.
        flow_cap:
          default: .inf
          title: Rated flow capacity.
          description: 'Sets `flow_cap` to a parameter in operate mode. NOTE: this
            parameter cannot be used in `base` mode as it clashes with the decision
            variable of the same name.'
          unit: power.
        link_flow_cap:
          default: .inf
          title: Rated link flow capacity.
          description: 'Sets `link_flow_cap` to a parameter in operate mode. NOTE:
            this parameter cannot be used in `base` mode as it clashes with the decision
            variable of the same name.'
          unit: power.
      constraints:
        flow_capacity_per_storage_capacity_min:
          active: false
        flow_capacity_per_storage_capacity_max:
          active: false
        source_capacity_equals_flow_capacity:
          active: false
        force_zero_area_use:
          active: false
        area_use_per_flow_capacity:
          active: false
        area_use_capacity_per_loc:
          active: false
        flow_capacity_systemwide_max:
          active: false
        flow_capacity_systemwide_min:
          active: false
        symmetric_transmission:
          active: false
        storage_capacity_units_milp:
          active: false
        flow_capacity_units_milp:
          active: false
        unit_capacity_max_systemwide_milp:
          active: false
        unit_capacity_min_systemwide_milp:
          active: false
      variables:
        flow_cap:
          active: false
        link_flow_cap:
          active: false
        area_use:
          active: false
        source_cap:
          active: false
        storage_cap:
          active: false
        purchased_units:
          active: false
      global_expressions:
        cost_investment:
          active: false
        cost_investment_annualised:
          active: false
        cost_investment_flow_cap:
          active: false
        cost_investment_storage_cap:
          active: false
        cost_investment_source_cap:
          active: false
        cost_investment_area_use:
          active: false
        cost_investment_purchase:
          active: false
        cost:
          where: cost_operation_variable
          equations:
          - expression: sum(cost_operation_variable, over=timesteps)
      checks:
        operate_mode_cyclic_storage:
          where: cyclic_storage==True AND (base_tech==storage OR 
            include_storage==True)
          message: 'Cyclic storage should be switched off in operate mode. Since the
            parameter defaults to True, make sure you explicitly set `cyclic_storage:
            false` for all your technologies with storage.'
          errors: raise
    spores:
      parameters:
        spores_baseline_cost:
          description: The baseline optimal cost of the system used to set the 
            maximum cost constraint when undertaking SPORES analysis. This 
            usually only applies to `monetary` cost, but could be applied to 
            other non-SPORES costs as necessary.
          default: .inf
          unit: cost
        spores_slack:
          description: The amount of slack in the maximum cost constraint 
            applied in SPORES mode. This is a fraction that is applied to the 
            baseline cost, e.g., `0.1` would be used to set a maximum cost 
            constraint of `spores_baseline_cost * 1.1`
          default: 0
          unit: unitless
        spores_score:
          description: The per-tech & per-node SPORES score used to penalise 
            technologies at nodes that have appeared in previous SPORES 
            iterations.
          default: 0
          unit: unitless
      constraints:
        total_system_cost_max:
          description: "Limit total system cost in SPORES mode. Applies a maximum
            relaxation to the system cost compared to the least-cost objective function
            value.\n"
          equations:
          - where: any(cost, over=[nodes, techs, costs])
            expression: "sum(\n  sum(cost, over=[nodes, techs])\n  * objective_cost_weights,\n\
              \  over=costs\n) + $unmet_demand <= spores_baseline_cost * (1 + spores_slack)"
          - where: NOT any(cost, over=[nodes, techs, costs])
            expression: $unmet_demand <= spores_baseline_cost * (1 + 
              spores_slack)
          sub_expressions:
            unmet_demand:
            - where: config.ensure_feasibility==True
              expression: "sum(\n  sum(unmet_demand - unused_supply, over=[carriers,
                nodes])\n  * timestep_weights,\n  over=timesteps\n) * bigM"
            - where: NOT config.ensure_feasibility==True
              expression: '0'
      global_expressions:
        spores_score_cumulative:
          description: Track SPORES score to include in the model results
          foreach:
          - nodes
          - techs
          - carriers
          equations:
          - expression: spores_score
          unit: unitless
          default: 0
        spores_baseline_cost_tracked:
          description: Track SPORES baseline cost to include in the model 
            results
          equations:
          - expression: spores_baseline_cost
          unit: cost
          default: .inf
      objectives:
        min_spores:
          description: SPORES score minimisation objective, activated for all 
            iterations after the baseline optimisation. The SPORES scores are 
            applied to flow capacity for each technology at each node.
          equations:
          - expression: sum(flow_cap * spores_score, over=[nodes, techs, 
              carriers]) + $unmet_demand
          sub_expressions:
            unmet_demand:
            - where: config.ensure_feasibility==True
              expression: "sum(\n  sum(unmet_demand - unused_supply, over=[carriers,
                nodes])\n  * timestep_weights,\n  over=timesteps\n) * bigM"
            - where: NOT config.ensure_feasibility==True
              expression: '0'
          sense: minimise
    storage_inter_cluster:
      lookups:
        timestep_cluster:
          description: The cluster to which each timestep belongs.
          dtype: float
          resample_method: first
        lookup_datestep_cluster:
          description: The cluster to which each datestep belongs.
          dtype: float
          resample_method: first
        lookup_datestep_last_cluster_timestep:
          description: The last timestep of each datestep cluster.
          dtype: datetime
          resample_method: first
      constraints:
        storage_max:
          active: false
        balance_supply_with_storage:
          sub_expressions:
            storage_previous_step:
            - where: timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True
              expression: storage_initial * storage_cap
            - where: "(\n  (timesteps==get_val_at_index(timesteps=0) AND cyclic_storage==True)\n\
                \  OR NOT timesteps==get_val_at_index(timesteps=0)\n) AND NOT lookup_cluster_last_timestep"
              expression: (1 - storage_loss) ** roll(timestep_resolution, 
                timesteps=1) * roll(storage, timesteps=1)
            - where: lookup_cluster_last_timestep AND NOT 
                (timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True)
              expression: '0'
        balance_storage:
          sub_expressions:
            storage_previous_step:
            - where: timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True
              expression: storage_initial * storage_cap
            - where: "(\n  (timesteps==get_val_at_index(timesteps=0) AND cyclic_storage==True)\n\
                \  OR NOT timesteps==get_val_at_index(timesteps=0)\n) AND NOT lookup_cluster_last_timestep"
              expression: (1 - storage_loss) ** roll(timestep_resolution, 
                timesteps=1) * roll(storage, timesteps=1)
            - where: lookup_cluster_last_timestep AND NOT 
                (timesteps==get_val_at_index(timesteps=0) AND NOT 
                cyclic_storage==True)
              expression: '0'
        set_storage_initial:
          equations:
          - expression: storage_inter_cluster[datesteps=$final_step] * ((1 - 
              storage_loss) ** 24) == storage_initial * storage_cap
          slices:
            final_step:
            - expression: get_val_at_index(datesteps=-1)
        storage_intra_max:
          description: Set the upper bound of a `storage` technology's stored 
            carrier within a clustered day
          foreach:
          - nodes
          - techs
          - timesteps
          where: include_storage==True OR base_tech==storage
          equations:
          - expression: storage <= storage_intra_cluster_max[clusters=$cluster]
          slices:
            cluster:
            - expression: timestep_cluster
        storage_intra_min:
          description: Set the lower bound of a `storage` technology's stored 
            carrier within a clustered day
          foreach:
          - nodes
          - techs
          - timesteps
          where: include_storage==True OR base_tech==storage
          equations:
          - expression: storage >= storage_intra_cluster_min[clusters=$cluster]
          slices:
            cluster:
            - expression: timestep_cluster
        storage_inter_max:
          description: Set the upper bound of a `storage` technology's stored 
            carrier across all days in the timeseries.
          foreach:
          - nodes
          - techs
          - datesteps
          where: include_storage==True OR base_tech==storage
          equations:
          - expression: storage_inter_cluster + 
              storage_intra_cluster_max[clusters=$cluster] <= storage_cap
          slices:
            cluster:
            - expression: lookup_datestep_cluster
        storage_inter_min:
          description: Set the lower bound of a `storage` technology's stored 
            carrier across all days in the timeseries.
          foreach:
          - nodes
          - techs
          - datesteps
          where: include_storage==True OR base_tech==storage
          equations:
          - expression: storage_inter_cluster * ((1 - storage_loss) ** 24) + 
              storage_intra_cluster_min[clusters=$cluster] >= 0
          slices:
            cluster:
            - expression: lookup_datestep_cluster
        balance_storage_inter:
          description: Fix the relationship between one day and the next of a 
            `storage` technology's available stored carrier, according to the 
            previous day's representative storage fluctuations and the excess 
            stored carrier available from all days up to this day.
          foreach:
          - nodes
          - techs
          - datesteps
          where: include_storage==True OR base_tech==storage
          equations:
          - expression: storage_inter_cluster == $storage_previous_step + 
              $storage_intra
          sub_expressions:
            storage_previous_step:
            - where: datesteps==get_val_at_index(datesteps=0) AND NOT 
                cyclic_storage==True
              expression: storage_initial
            - where: (datesteps==get_val_at_index(datesteps=0) AND 
                cyclic_storage==True) OR NOT 
                datesteps==get_val_at_index(datesteps=0)
              expression: ((1 - storage_loss) ** 24) * 
                roll(storage_inter_cluster, datesteps=1)
            storage_intra:
            - where: datesteps==get_val_at_index(datesteps=0) AND NOT 
                cyclic_storage==True
              expression: '0'
            - where: NOT (datesteps==get_val_at_index(datesteps=0) AND NOT 
                cyclic_storage==True)
              expression: storage[timesteps=$final_step]
          slices:
            final_step:
            - expression: roll(lookup_datestep_last_cluster_timestep, 
                datesteps=1)
      variables:
        storage:
          title: Virtual stored carrier
          description: The virtual carrier stored by any technology using 
            storage in each timestep of a clustered day. Stored carrier can be 
            negative so long as it does not go below the carrier stored in 
            `storage_inter_cluster`. Only together with `storage_inter_cluster` 
            does this variable's values gain physical significance.
          unit: energy
          bounds:
            min: -.inf
        storage_inter_cluster:
          title: Virtual inter-cluster stored carrier
          description: The virtual carrier stored by any technology using 
            storage between days of the entire timeseries. Only together with 
            `storage` does this variable's values gain physical significance.
          unit: energy
          default: 0
          foreach:
          - nodes
          - techs
          - datesteps
          where: include_storage==True OR base_tech==storage
          bounds:
            min: 0
            max: .inf
        storage_intra_cluster_max:
          title: Virtual maximum intra-cluster stored carrier
          description: Virtual variable to limit the maximum value of `storage` 
            in a given representative day.
          unit: energy
          default: .inf
          foreach:
          - nodes
          - techs
          - clusters
          where: include_storage==True OR base_tech==storage
          bounds:
            min: -.inf
            max: .inf
        storage_intra_cluster_min:
          title: Virtual minimum intra-cluster stored carrier
          description: Virtual variable to limit the minimum value of `storage` 
            in a given representative day.
          unit: energy
          default: -.inf
          foreach:
          - nodes
          - techs
          - clusters
          where: include_storage==True OR base_tech==storage
          bounds:
            min: -.inf
            max: .inf
  build:
    dimensions:
      carriers:
        title: Energy / commodity carriers
        description: ''
        active: true
        dtype: string
        ordered: false
        iterator: carrier
      costs:
        title: Cost classes
        description: ''
        active: true
        dtype: string
        ordered: false
        iterator: cost
      nodes:
        title: Geographic spatial nodes
        description: ''
        active: true
        dtype: string
        ordered: false
        iterator: node
      techs:
        title: Technologies
        description: ''
        active: true
        dtype: string
        ordered: false
        iterator: tech
      timesteps:
        title: Time steps
        description: ''
        active: true
        dtype: datetime
        ordered: true
        iterator: timestep
      clusters:
        title: Date clusters
        description: ''
        active: true
        dtype: integer
        ordered: true
        iterator: cluster
      datesteps:
        title: Date steps
        description: ''
        active: true
        dtype: date
        ordered: true
        iterator: datestep
    parameters:
      area_use_max:
        title: Maximum usable area.
        description: If set to a finite value, limits the upper bound of the 
          `area_use` decision variable to this value.
        active: true
        default: .inf
        resample_method: first
        unit: $\text{area}$
      area_use_min:
        title: Minimum usable area.
        description: Limits the lower bound of the `area_use` decision variable 
          to this value.
        active: true
        default: 0
        resample_method: first
        unit: $\text{area}$
      area_use_per_flow_cap:
        title: Area use per flow capacity
        description: If set, forces `area_use` to follow `flow_cap` with the 
          given numerical ratio (e.g. setting to 1.5 means that `area_use == 1.5
          * flow_cap`).
        active: true
        default: .nan
        resample_method: first
        unit: $\frac{\text{area}}{\text{power}}$
      available_area:
        title: Available area
        description: Available area for resource area use by all technologies at
          a node.
        active: true
        default: .inf
        resample_method: mean
        unit: area.
      bigM:
        title: Big M
        description: BigM is a large value used to define certain optimisation 
          problems. See https://en.wikipedia.org/wiki/Big_M_method for more 
          information. This value should be larger than the largest values that 
          any decision variables can take, but should not be **too** large 
          (i.e., do not set it greater than 3 orders of magnitude above the 
          numeric range of the model). If too large, numerical problems may 
          arise in the optimisation.
        active: true
        default: 1000000.0
        resample_method: first
        unit: unitless
      cost_flow_cap_per_distance:
        title: Cost of flow capacity, per unit distance
        description: Cost per unit of the decision variable `flow_cap` and per 
          unit distance of a transmission link. Applied to transmission links 
          only.
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{power}\times\text{distance}}$
      cost_purchase_per_distance:
        title: Purchase cost per unit distance for transmission techs.
        description: Cost applied if the binary variable `purchased` is 1 or per
          unit of the integer variable `units`. Requires the parameter 
          `cap_method` to be `integer`.
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{unit}\times\text{distance}}$
      cost_flow_cap:
        title: Cost of flow capacity.
        description: Cost per unit of the decision variable `flow_cap`.
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{power}}$
      cost_export:
        title: Carrier export cost.
        description: Cost per unit of `flow_export` in each timestep. Usually 
          used in the negative sense, as a subsidy.
        active: true
        default: 0
        resample_method: mean
        unit: $\frac{\{cost}}{\text{energy}}$
      cost_interest_rate:
        title: Interest rate.
        description: Used when computing levelized costs and technology 
          depreciation_rate (relative to lifetime).
        active: true
        default: 0
        resample_method: first
        unit: unitless
      cost_om_annual:
        title: Annual O&M costs
        description: Annual costs applied per unit `flow_cap`. These costs are 
          not subject to being recalculated relative to technology lifetime, 
          only scaled to reflect the fraction of one year that the model 
          represents (e.g., 7 days ~= 0.02 of a year).
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{power}}$
      cost_om_annual_investment_fraction:
        title: Fractional annual O&M costs.
        description: Add an additional cost to total investment costs (except 
          `cost_om_annual`) that is a fraction of that total.
        active: true
        default: 0
        resample_method: first
        unit: unitless.
      cost_flow_in:
        title: Carrier inflow cost.
        description: Cost per unit of `flow_in` in each timestep. Also used as 
          the cost per unit of `source_use` in `supply` technologies.
        active: true
        default: 0
        resample_method: mean
        unit: $\frac{\{cost}}{\text{energy}}$
      cost_flow_out:
        title: Carrier outflow cost
        description: Cost per unit of `flow_out` in each timestep.
        active: true
        default: 0
        resample_method: mean
        unit: $\frac{\{cost}}{\text{energy}}$
      cost_purchase:
        title: Purchase cost.
        description: Cost applied to the variable `purchased_units`. Requires 
          the parameter `cap_method` to be `integer`.
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{unit}}$
      cost_area_use:
        title: Cost of area use.
        description: Cost per unit `area_use`.
        active: true
        default: 0
        resample_method: first
        unit: $\text{area}$
      cost_source_cap:
        title: Cost of source flow capacity.
        description: Cost per unit `source_cap`.
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{power}}$
      cost_storage_cap:
        title: Cost of storage capacity.
        description: Cost per unit `storage_cap`, i.e., the maximum available 
          capacity of the storage technology's "reservoir".
        active: true
        default: 0
        resample_method: first
        unit: $\frac{\{cost}}{\text{energy}}$
      cost_depreciation_rate:
        title: Depreciation rate.
        description: Applied to "annualise" investment costs so they are 
          comparable to variable costs. If not provided, this will be calculated
          using technology `lifetime` and `cost_interest_rate`.
        active: true
        default: 1
        resample_method: first
        unit: unitless.
      distance:
        title: Distance spanned by link.
        description: Used for `..._per_distance` constraints. If not defined, it
          will be automatically derived from latitude/longitude of nodes in a 
          link.
        active: true
        default: 1.0
        resample_method: mean
        unit: distance.
      export_max:
        title: Maximum allowed carrier export
        description: If `carrier_export` is defined, limit the allowed export of
          produced carrier for a technology.
        active: true
        default: .inf
        resample_method: first
        unit: power.
      export_min:
        title: Minimum allowed carrier export
        description: If `carrier_export` is defined, set a lower bound on the 
          amount of produced carrier that _must_ be exported for a technology.
        active: true
        default: 0
        resample_method: first
        unit: power.
      flow_cap_per_storage_cap_min:
        title: Minimum flow capacity per storage capacity
        description: ratio of minimum charge/discharge (kW) for a given storage 
          capacity (kWh).
        active: true
        default: 0
        resample_method: first
        unit: $\text{hour}^{-1}$
      flow_cap_per_storage_cap_max:
        title: Maximum flow capacity per storage capacity
        description: ratio of maximum charge/discharge (kW) for a given storage 
          capacity (kWh).
        active: true
        default: .inf
        resample_method: first
        unit: $\text{hour}^{-1}$
      flow_cap_max:
        title: Maximum rated flow capacity.
        description: Limits `flow_cap` to a maximum.
        active: true
        default: .inf
        resample_method: first
        unit: power.
      flow_cap_max_systemwide:
        title: System-wide maximum rated flow capacity.
        description: Limits the sum of `flow_cap` over all nodes in the model to
          a maximum. If `cap_method=integer`, this will be scaled by the number 
          of integer units of a technology purchased.
        active: true
        default: .inf
        resample_method: first
        unit: power or $\frac{\text{power}}{\text{unit}}$
      flow_cap_min:
        title: Minimum rated flow capacity.
        description: 'Limits `flow_cap` to a minimum. NOTE: this will _force_ `flow_cap`
          to a minimum value unless `cap_method` is set to `integer`. If `cap_method=integer`,
          this will be scaled by the number of integer units of a technology purchased.'
        active: true
        default: 0
        resample_method: first
        unit: power or $\frac{\text{power}}{\text{unit}}$
      flow_cap_min_systemwide:
        title: System-wide minimum rated flow capacity.
        description: 'Limits the sum of `flow_cap` over all nodes in the model to
          a minimum. NOTE: this will _force_ the sum of `flow_cap` to a minimum value
          unless `cap_method` is set to `integer`.'
        active: true
        default: 0
        resample_method: first
        unit: power.
      flow_out_min_relative:
        title: Minimum outflow
        description: Set to a value between 0 and 1 to force minimum `flow_out` 
          as a fraction of the technology rated capacity. If non-zero and 
          `cap_method` is `continuous`, this will force the technology to 
          operate above its minimum value at every timestep.
        active: true
        default: 0
        resample_method: mean
        unit: unitless.
      flow_cap_per_unit:
        title: Flow capacity per purchased unit
        description: Set the capacity of each integer unit of a technology 
          purchased, if `cap_method` is `integer`.
        active: true
        default: .inf
        resample_method: first
        unit: $\frac{\text{power}}{\text{unit}}$
      flow_in_eff:
        title: Inflow efficiency
        description: Conversion efficiency from `source`/`flow_in` (tech 
          dependent) into the technology. Set as value between 1 (no loss) and 0
          (all lost).
        active: true
        default: 1.0
        resample_method: mean
        unit: unitless.
      flow_in_eff_per_distance:
        title: Inflow (i.e., export from node) efficiency per distance of 
          transmission links.
        description: Total link efficiency will be calculated as 
          $\text{flow\_in\_eff}\times{}\text{flow\_in\_eff\_per\_distance}^\text{distance}$.
          Set as value between 1 (no loss) and 0 (all lost).
        active: true
        default: 1.0
        resample_method: mean
        unit: $\frac{\text{1}}{\text{distance}}$
      flow_out_eff:
        title: Outflow efficiency
        description: Conversion efficiency from the technology to 
          `sink`/`flow_out` (tech dependent). Set as value between 1 (no loss) 
          and 0 (all lost).
        active: true
        default: 1.0
        resample_method: mean
        unit: unitless.
      flow_out_eff_per_distance:
        title: Outflow (i.e., import from node) efficiency per distance of 
          transmission links.
        description: Total link efficiency will be calculated as 
          $\text{flow\_out\_eff}\times{}\text{flow\_out\_eff\_per\_distance}^\text{distance}$.
          Set as value between 1 (no loss) and 0 (all lost).
        active: true
        default: 1.0
        resample_method: mean
        unit: $\frac{\text{1}}{\text{distance}}$
      flow_out_parasitic_eff:
        title: Plant parasitic efficiency
        description: Additional losses as flow gets transferred from the plant 
          to the carrier, e.g. due to plant parasitic consumption. Set as value 
          between 1 (no loss) and 0 (all lost).
        active: true
        default: 1.0
        resample_method: mean
        unit: unitless.
      flow_ramping:
        title: Ramping rate
        description: limit maximum outflow / inflow / outflow - inflow 
          (technology base class dependent) to a fraction of maximum capacity, 
          which increases by that fraction at each timestep.
        active: true
        default: 1.0
        resample_method: first
        unit: $\frac{1}{\text{hour}}$
      lifetime:
        title: Technology lifetime
        description: Must be defined if fixed capital costs are defined. A 
          reasonable value for many technologies is around 20-25 years.
        active: true
        default: .inf
        resample_method: mean
        unit: years.
      objective_cost_weights:
        title: Objective cost class weights.
        description: Weightings for cost classes to apply in the objective 
          function.
        active: true
        default: 1
        resample_method: first
        unit: unitless
      purchased_units_min_systemwide:
        title: System-wide minimum installed integer units of a technology.
        description: sets the lower bound of the sum across all nodes of the 
          decision variable `units` for a particular technology.
        active: true
        default: 0
        resample_method: first
        unit: integer.
      purchased_units_max_systemwide:
        title: System-wide maximum installed integer units of a technology.
        description: sets the upper bound of the sum across all nodes of the 
          decision variable `units` for a particular technology.
        active: true
        default: .inf
        resample_method: first
        unit: integer.
      purchased_units_min:
        title: Minimum number of purchased units
        description: Limits the lower bound of units purchased if `cap_method` 
          is `integer`.
        active: true
        default: 0
        resample_method: first
        unit: integer.
      purchased_units_max:
        title: Maximum number of purchased units.
        description: Limits the upper bound of units purchased if `cap_method` 
          is `integer`. If set to `1`, will effectively set the 
          `purchased_units` to a binary decision variable.
        active: true
        default: .inf
        resample_method: first
        unit: integer.
      sink_use_min:
        title: Minimum bound on sink.
        description: Minimum sink use to remove a carrier from the system (e.g.,
          electricity demand, transport distance). Unit dictated by 
          `source_unit`.
        active: true
        default: 0
        resample_method: sum
        unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
          $\frac{\text{energy}}{\text{area}}$
      sink_use_max:
        title: Maximum bound on sink.
        description: Maximum sink use to remove a carrier from the system (e.g.,
          electricity demand, transport distance). Unit dictated by 
          `source_unit`.
        active: true
        default: .inf
        resample_method: sum
        unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
          $\frac{\text{energy}}{\text{area}}$
      sink_use_equals:
        title: Required sink use.
        description: Required amount of carrier removal from the system (e.g., 
          electricity demand, transport distance). Unit dictated by 
          `source_unit`.
        active: true
        default: .nan
        resample_method: sum
        unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
          $\frac{\text{energy}}{\text{area}}$
      source_eff:
        title: Source inflow efficiency
        description: Conversion efficiency from the technology from `source`. 
          Set as value between 1 (no loss) and 0 (all lost).
        active: true
        default: 1.0
        resample_method: mean
        unit: unitless.
      source_use_min:
        title: Minimum bound on source.
        description: Minimum source use to add a carrier from the system (e.g., 
          biofuel, coal, rainfall, wind flow). Unit dictated by `source_unit`.
        active: true
        default: 0
        resample_method: sum
        unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
          $\frac{\text{energy}}{\text{area}}$
      source_use_max:
        title: Maximum bound on sink.
        description: Maximum sink use to remove a carrier from the system (e.g.,
          biofuel, coal, rainfall, wind flow). Unit dictated by `source_unit`.
        active: true
        default: .inf
        resample_method: sum
        unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
          $\frac{\text{energy}}{\text{area}}$
      source_use_equals:
        title: Required sink use.
        description: Required amount of carrier removal from the system (e.g., 
          biofuel, coal, rainfall, wind flow). Unit dictated by `source_unit`.
        active: true
        default: .nan
        resample_method: sum
        unit: energy | $\frac{\text{energy}}{\text{power}}$ | 
          $\frac{\text{energy}}{\text{area}}$
      source_cap_max:
        title: Maximum installed source consumption capacity.
        description: Upper limit on `source_cap` decision variable.
        active: true
        default: .inf
        resample_method: mean
        unit: power.
      source_cap_min:
        title: Minimum installed source consumption capacity
        description: Lower limit on `source_cap` decision variable.
        active: true
        default: 0
        resample_method: mean
        unit: power.
      storage_cap_max:
        title: Maximum storage capacity.
        description: Limit upper bound of `storage_cap` decision variable.
        active: true
        default: .inf
        resample_method: first
        unit: energy.
      storage_cap_min:
        title: Minimum storage capacity.
        description: Limit lower bound of `storage_cap` decision variable.
        active: true
        default: 0
        resample_method: first
        unit: energy.
      storage_cap_per_unit:
        title: Storage capacity per purchased unit.
        description: Set the storage capacity of each integer unit of a 
          technology purchased.
        active: true
        default: .inf
        resample_method: first
        unit: $\frac{\text{energy}}{\text{unit}}$
      storage_discharge_depth:
        title: Storage depth of discharge.
        description: Defines the minimum level of storage state of charge, as a 
          fraction of total storage capacity.
        active: true
        default: 0
        resample_method: mean
        unit: unitless.
      storage_initial:
        title: Initial storage level.
        description: Set stored flow in device at the first timestep, as a 
          fraction of total storage capacity.
        active: true
        default: 0
        resample_method: first
        unit: unitless.
      storage_loss:
        title: Storage loss rate
        description: Rate of storage loss per hour, used to calculate lost 
          stored flow as `(1 - storage_loss)^hours_per_timestep`.
        active: true
        default: 0
        resample_method: mean
        unit: $\frac{\text{1}}{\text{hour}}$
      timestep_resolution:
        title: Resolution per timestep.
        description: ''
        active: true
        default: 1
        resample_method: sum
        unit: hours.
      timestep_weights:
        title: Weight per timestep.
        description: ''
        active: true
        default: 1
        resample_method: mean
        unit: unitless.
      area_use:
        title: Area used.
        description: 'Sets `area_use` to a parameter in operate mode. NOTE: this parameter
          cannot be used in `base` mode as it clashes with the decision variable of
          the same name.'
        active: true
        default: .inf
        resample_method: first
        unit: $\text{area}$.
      storage_cap:
        title: Rated storage capacity.
        description: 'Sets `storage_cap` to a parameter in operate mode. NOTE: this
          parameter cannot be used in `base` mode as it clashes with the decision
          variable of the same name.'
        active: true
        default: .inf
        resample_method: first
        unit: $\text{area}$.
      purchased_units:
        title: Number of purchased units.
        description: 'Sets `purchased_units` to a parameter in operate mode. NOTE:
          this parameter cannot be used in `base` mode as it clashes with the decision
          variable of the same name.'
        active: true
        default: .inf
        resample_method: first
        unit: integer
      source_cap:
        title: Installed source consumption capacity.
        description: 'Sets `source_cap` to a parameter in operate mode. NOTE: this
          parameter cannot be used in `base` mode as it clashes with the decision
          variable of the same name.'
        active: true
        default: .inf
        resample_method: first
        unit: power.
      flow_cap:
        title: Rated flow capacity.
        description: 'Sets `flow_cap` to a parameter in operate mode. NOTE: this parameter
          cannot be used in `base` mode as it clashes with the decision variable of
          the same name.'
        active: true
        default: .inf
        resample_method: first
        unit: power.
      link_flow_cap:
        title: Rated link flow capacity.
        description: 'Sets `link_flow_cap` to a parameter in operate mode. NOTE: this
          parameter cannot be used in `base` mode as it clashes with the decision
          variable of the same name.'
        active: true
        default: .inf
        resample_method: first
        unit: power.
    lookups:
      base_tech:
        title: Abstract base technology name.
        description: Should be the name of one of the abstract base classes, 
          from which some initial parameter defaults will be derived and with 
          which certain base math will be triggered.
        active: true
        default: .nan
        dtype: string
        resample_method: first
        one_of:
        - demand
        - supply
        - conversion
        - storage
        - transmission
        pivot_values_to_dim:
      carrier_in:
        title: ''
        description: Carrier(s) consumed by this technology. Only 
          `transmission`, `conversion`, `storage`, and `demand` technologies can
          define this parameter
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim: carriers
      carrier_out:
        title: ''
        description: Carrier(s) produced by this technology. Only 
          `transmission`, `conversion`, `storage`, and `supply` technologies can
          define this parameter
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim: carriers
      carrier_export:
        title: ''
        description: Carrier(s) produced by this technology that can be exported
          out of the system boundaries without having to go to a pre-defined 
          `sink` (i.e., via a `demand` technology). Must be a subset of 
          `carrier_out`.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim: carriers
      cap_method:
        title: Capacity method switch.
        description: One of 'continuous' (LP model) or 'integer' (integer/binary
          unit capacity).
        active: true
        default: continuous
        dtype: string
        resample_method: first
        one_of:
        - continuous
        - integer
        pivot_values_to_dim:
      cluster_first_timestep:
        title: Cluster first timestep.
        description: If true, the timestep is the first in the given clustered 
          day.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      definition_matrix:
        title: ''
        description: Whether a technology is defined with particular carriers 
          and at a particular node.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      integer_dispatch:
        title: Integer dispatch switch.
        description: "When true, will limit per-timestep out/inflows relative to the
          number of units of a technology that are in operation.\nRequires `cap_method=integer`.\n"
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      include_storage:
        title: Storage method switch.
        description: When true, math will be triggered to allow discontinuous 
          carrier inflow and outflows across timesteps.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      force_async_flow:
        title: Force asynchronous out/inflow.
        description: If True, non-zero `flow_out` and `flow_in` cannot both 
          occur in the same timestep.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      cyclic_storage:
        title: Cyclic storage switch.
        description: "If true, link storage levels in the last model timestep with
          the first model timestep. `inter_cluster_storage` custom math must be included
          if using time clustering and setting this to `true`. This must be set to
          `false` if using `operate` mode.\n"
        active: true
        default: true
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      sink_unit:
        title: Sink unit
        description: 'Sets the unit of `Sink` to either `absolute` (unit: `energy`),
          `per_area` (unit: `energy/area`), or `per_cap` (unit: `energy/power`). `per_area`
          uses the `area_use` decision variable to scale the sink while `per_cap`
          uses the `flow_cap` decision variable.'
        active: true
        default: absolute
        dtype: string
        resample_method: first
        one_of:
        - absolute
        - per_area
        - per_cap
        pivot_values_to_dim:
      source_unit:
        title: Source unit
        description: 'Sets the unit of `Source` to either `absolute` (unit: `energy`),
          `per_area` (unit: `energy/area`), or `per_cap` (unit: `energy/power`). `per_area`
          uses the `area_use` decision variable to scale the source while `per_cap`
          uses the `flow_cap` decision variable.'
        active: true
        default: absolute
        dtype: string
        resample_method: first
        one_of:
        - absolute
        - per_area
        - per_cap
        pivot_values_to_dim:
      source_cap_equals_flow_cap:
        title: Source capacity equals flow capacity.
        description: If true, the decision variables `source_cap` and `flow_cap`
          are forced to equal one another.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      one_way:
        title: One way transmission.
        description: Forces a transmission technology to only move flow in one 
          direction on the link, i.e. from `from` to `to`.
        active: true
        default: false
        dtype: bool
        resample_method: first
        one_of:
        pivot_values_to_dim:
      lookup_cluster_last_timestep:
        title: ''
        description: The last timestep of each cluster.
        active: true
        default: .nan
        dtype: datetime
        resample_method: first
        one_of:
        pivot_values_to_dim:
      latitude:
        title: Latitude (WGS84 / EPSG4326).
        description: ''
        active: true
        default: .nan
        dtype: float
        resample_method: mean
        one_of:
        pivot_values_to_dim:
      longitude:
        title: Longitude (WGS84 / EPSG4326).
        description: ''
        active: true
        default: .nan
        dtype: float
        resample_method: mean
        one_of:
        pivot_values_to_dim:
    variables:
      flow_cap:
        title: Technology flow (a.k.a. nominal) capacity
        description: A technology's flow capacity, also known as its nominal or 
          nameplate capacity.
        active: false
        foreach:
        - nodes
        - techs
        - carriers
        where: 'True'
        unit: power
        default: 0
        domain: real
        bounds:
          max: flow_cap_max
          min: flow_cap_min
      link_flow_cap:
        title: Link flow capacity
        description: A transmission technology's flow capacity, also known as 
          its nominal or nameplate capacity.
        active: false
        foreach:
        - techs
        where: base_tech==transmission
        unit: power
        default: 0
        domain: real
        bounds:
          max: .inf
          min: 0
      flow_out:
        title: Carrier outflow
        description: The outflow of a technology per timestep, also known as the
          flow discharged (from `storage` technologies) or the flow received (by
          `transmission` technologies) on a link.
        active: true
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: carrier_out
        unit: energy
        default: 0
        domain: real
        bounds:
          max: .inf
          min: 0
      flow_in:
        title: Carrier inflow
        description: The inflow to a technology per timestep, also known as the 
          flow consumed (by `storage` technologies) or the flow sent (by 
          `transmission` technologies) on a link.
        active: true
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: carrier_in
        unit: energy
        default: 0
        domain: real
        bounds:
          max: .inf
          min: 0
      flow_export:
        title: Carrier export
        description: The flow of a carrier exported outside the system 
          boundaries by a technology per timestep.
        active: true
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: carrier_export
        unit: energy
        default: 0
        domain: real
        bounds:
          max: export_max
          min: export_min
      area_use:
        title: Area utilisation
        description: The area in space utilised directly (e.g., solar PV panels)
          or indirectly (e.g., biofuel crops) by a technology.
        active: false
        foreach:
        - nodes
        - techs
        where: (area_use_min OR area_use_max OR area_use_per_flow_cap OR 
          sink_unit==per_area OR source_unit==per_area)
        unit: area
        default: 0
        domain: real
        bounds:
          max: area_use_max
          min: area_use_min
      source_use:
        title: Source flow use
        description: The carrier flow consumed from outside the system 
          boundaries by a `supply` technology.
        active: true
        foreach:
        - nodes
        - techs
        - timesteps
        where: base_tech==supply
        unit: energy
        default: 0
        domain: real
        bounds:
          max: .inf
          min: 0
      source_cap:
        title: Source flow capacity
        description: The upper limit on a flow that can be consumed from outside
          the system boundaries by a `supply` technology in each timestep.
        active: false
        foreach:
        - nodes
        - techs
        where: base_tech==supply
        unit: power
        default: 0
        domain: real
        bounds:
          max: source_cap_max
          min: source_cap_min
      storage_cap:
        title: Stored carrier capacity
        description: The upper limit on a carrier that can be stored by a 
          technology in any timestep.
        active: false
        foreach:
        - nodes
        - techs
        where: include_storage==True OR base_tech==storage
        unit: energy
        default: 0
        domain: real
        bounds:
          max: storage_cap_max
          min: storage_cap_min
      storage:
        title: Stored carrier
        description: The carrier stored by a `storage` technology in each 
          timestep.
        active: true
        foreach:
        - nodes
        - techs
        - timesteps
        where: include_storage==True OR base_tech==storage
        unit: energy
        default: 0
        domain: real
        bounds:
          max: .inf
          min: 0
      unmet_demand:
        title: Unmet demand (load shedding)
        description: Virtual source of carrier flow to ensure model feasibility.
          This should only be considered a debugging rather than a modelling 
          tool as it may distort the model in other ways due to the large impact
          it has on the objective function value. When present in a model in 
          which it has been requested, it indicates an inability for 
          technologies in the model to reach a sufficient combined supply 
          capacity to meet demand.
        active: true
        foreach:
        - nodes
        - carriers
        - timesteps
        where: config.ensure_feasibility==True
        unit: energy
        default: 0
        domain: real
        bounds:
          max: .inf
          min: 0
      unused_supply:
        title: Unused supply (curtailment)
        description: 'Virtual sink of carrier flow to ensure model feasibility. This
          should only be considered a debugging rather than a modelling tool as it
          may distort the model in other ways due to the large impact it has on the
          objective function value. In model results, the negation of this variable
          is combined with `unmet_demand` and presented as only one variable: `unmet_demand`.
          When present in a model in which it has been requested, it indicates an
          inability for technologies in the model to reach a sufficient combined consumption
          capacity to meet required outflow (e.g. from renewables without the possibility
          of curtailment).'
        active: true
        foreach:
        - nodes
        - carriers
        - timesteps
        where: config.ensure_feasibility==True
        unit: energy
        default: 0
        domain: real
        bounds:
          max: 0
          min: -.inf
      purchased_units:
        title: ''
        description: ''
        active: false
        foreach: []
        where: 'True'
        unit: ''
        default: .nan
        domain: real
        bounds:
          max: .inf
          min: -.inf
    global_expressions:
      flow_out_inc_eff:
        title: Carrier outflow including losses
        description: Outflows after taking efficiency losses into account.
        active: true
        equations:
        - where: base_tech==transmission
          expression: "flow_out / (\n  flow_out_eff * flow_out_parasitic_eff *\n \
            \ flow_out_eff_per_distance ** distance\n)"
        - where: NOT base_tech==transmission
          expression: flow_out / (flow_out_eff * flow_out_parasitic_eff)
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: flow_out
        unit: energy
        default: 0
        order: 0
      flow_in_inc_eff:
        title: Carrier inflow including losses
        description: Inflows after taking efficiency losses into account.
        active: true
        equations:
        - where: base_tech==transmission
          expression: flow_in * flow_in_eff * flow_in_eff_per_distance ** 
            distance
        - where: NOT base_tech==transmission
          expression: flow_in * flow_in_eff
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: flow_in
        unit: energy
        default: 0
        order: 0
      cost_operation_variable:
        title: Variable operating costs
        description: The operating costs per timestep of a technology.
        active: true
        equations:
        - where: 'True'
          expression: timestep_weights * ($cost_export + $cost_flow_out + 
            $cost_flow_in)
        sub_expressions:
          cost_export:
          - where: any(carrier_export, over=carriers) AND any(cost_export, 
              over=carriers)
            expression: sum(cost_export * flow_export, over=carriers)
          - where: NOT (any(carrier_export, over=carriers) AND any(cost_export, 
              over=carriers))
            expression: '0'
          cost_flow_in:
          - where: base_tech==supply
            expression: cost_flow_in * source_use
          - where: NOT base_tech==supply
            expression: sum(cost_flow_in * flow_in, over=carriers)
          cost_flow_out:
          - where: 'True'
            expression: sum(cost_flow_out * flow_out, over=carriers)
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        - timesteps
        where: cost_export OR cost_flow_in OR cost_flow_out
        unit: $\frac{\text{cost}}{\text{hour}}$
        default: 0
        order: 0
      cost_investment_flow_cap:
        title: Flow capacity investment costs
        description: The investment costs associated with the nominal/rated 
          capacity of a technology.
        active: false
        equations:
        - where: 'True'
          expression: $cost_sum * flow_cap
        sub_expressions:
          cost_sum:
          - where: base_tech==transmission
            expression: (cost_flow_cap + cost_flow_cap_per_distance * distance) 
              * 0.5
          - where: NOT base_tech==transmission
            expression: cost_flow_cap
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - costs
        where: flow_cap AND (cost_flow_cap OR cost_flow_cap_per_distance)
        unit: cost
        default: 0
        order: 0
      cost_investment_storage_cap:
        title: Storage capacity investment costs
        description: The investment costs associated with the storage capacity 
          of a technology.
        active: false
        equations:
        - where: 'True'
          expression: cost_storage_cap * storage_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_storage_cap AND storage_cap
        unit: cost
        default: 0
        order: 0
      cost_investment_source_cap:
        title: Source flow capacity investment costs
        description: The investment costs associated with the source consumption
          capacity of a technology.
        active: false
        equations:
        - where: 'True'
          expression: cost_source_cap * source_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_source_cap AND source_cap
        unit: cost
        default: 0
        order: 0
      cost_investment_area_use:
        title: Area utilisation investment costs
        description: The investment costs associated with the area used by a 
          technology.
        active: false
        equations:
        - where: 'True'
          expression: cost_area_use * area_use
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_area_use AND area_use
        unit: cost
        default: 0
        order: 0
      cost_investment:
        title: Total investment costs
        description: The installation costs of a technology, including those 
          linked to the nameplate capacity, land use, and storage size.
        active: false
        equations:
        - where: 'True'
          expression: sum(cost_investment_flow_cap, over=carriers) + 
            cost_investment_storage_cap + cost_investment_source_cap + 
            cost_investment_area_use
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_investment_flow_cap OR cost_investment_storage_cap OR 
          cost_investment_source_cap OR cost_investment_area_use
        unit: cost
        default: 0
        order: 0
      cost_investment_annualised:
        title: Equivalent annual investment costs
        description: An annuity factor has been applied to scale lifetime 
          investment costs to annual values that can be directly compared to 
          operation costs. If the modeling period is not equal to one full year,
          this will be scaled accordingly.
        active: false
        equations:
        - where: 'True'
          expression: $annualisation_weight * $depreciation_rate * 
            cost_investment
        sub_expressions:
          annualisation_weight:
          - where: 'True'
            expression: sum(timestep_resolution * timestep_weights, 
              over=timesteps) / 8760
          depreciation_rate:
          - where: cost_depreciation_rate
            expression: cost_depreciation_rate
          - where: NOT cost_depreciation_rate AND cost_interest_rate==0
            expression: 1 / lifetime
          - where: NOT cost_depreciation_rate AND cost_interest_rate>0
            expression: (cost_interest_rate * ((1 + cost_interest_rate) ** 
              lifetime)) / (((1 + cost_interest_rate) ** lifetime) - 1)
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_investment
        unit: cost
        default: 0
        order: 0
      cost_operation_fixed:
        title: Total fixed operation costs
        description: The fixed, annual operation costs of a technology, which 
          are calculated relative to investment costs. If the modeling period is
          not equal to one full year, this will be scaled accordingly.
        active: true
        equations:
        - where: 'True'
          expression: "$annualisation_weight * (\n  sum(cost_om_annual * flow_cap,
            over=carriers) +\n  cost_investment * cost_om_annual_investment_fraction\n\
            )"
        sub_expressions:
          annualisation_weight:
          - where: 'True'
            expression: sum(timestep_resolution * timestep_weights, 
              over=timesteps) / 8760
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_investment AND (cost_om_annual OR 
          cost_om_annual_investment_fraction)
        unit: cost
        default: 0
        order: 0
      cost:
        title: Total costs
        description: The total annualised costs of a technology, including 
          installation and operation costs.
        active: true
        equations:
        - where: 'True'
          expression: sum(cost_operation_variable, over=timesteps)
        sub_expressions:
          cost_operation_sum:
          - where: cost_operation_variable
            expression: sum(cost_operation_variable, over=timesteps)
          - where: NOT cost_operation_variable
            expression: '0'
        slices: {}
        foreach:
        - nodes
        - techs
        - costs
        where: cost_operation_variable
        unit: cost
        default: 0
        order: 0
      cost_investment_purchase:
        title: ''
        description: ''
        active: false
        equations: []
        sub_expressions: {}
        slices: {}
        foreach: []
        where: 'True'
        unit: ''
        default: .nan
        order: 0
    constraints:
      flow_capacity_per_storage_capacity_min:
        title: ''
        description: Set the lower bound of storage flow capacity relative to 
          its storage capacity.
        active: false
        equations:
        - where: 'True'
          expression: flow_cap >= storage_cap * flow_cap_per_storage_cap_min
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        where: storage_cap AND flow_cap_per_storage_cap_min
      flow_capacity_per_storage_capacity_max:
        title: ''
        description: Set the upper bound of storage flow capacity relative to 
          its storage capacity.
        active: false
        equations:
        - where: 'True'
          expression: flow_cap <= storage_cap * flow_cap_per_storage_cap_max
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        where: storage_cap AND flow_cap_per_storage_cap_max
      source_capacity_equals_flow_capacity:
        title: ''
        description: Set a `supply` technology's flow capacity to equal its 
          source capacity.
        active: false
        equations:
        - where: 'True'
          expression: source_cap == flow_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        where: source_cap AND source_cap_equals_flow_cap==True
      force_zero_area_use:
        title: ''
        description: Set a technology's area use to zero if its flow capacity 
          upper bound is zero.
        active: false
        equations:
        - where: 'True'
          expression: area_use == 0
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        where: area_use AND flow_cap_max==0
      area_use_per_flow_capacity:
        title: ''
        description: Set a fixed relationship between a technology's flow 
          capacity and its area use.
        active: false
        equations:
        - where: 'True'
          expression: area_use == flow_cap * area_use_per_flow_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        where: area_use AND area_use_per_flow_cap
      area_use_capacity_per_loc:
        title: ''
        description: Set an upper bound on the total area that all technologies 
          with `area_use` can occupy at a given node.
        active: false
        equations:
        - where: 'True'
          expression: sum(area_use, over=techs) <= available_area
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        where: area_use AND available_area
      flow_capacity_systemwide_max:
        title: ''
        description: Set an upper bound on flow capacity of a technology across 
          all nodes in which the technology exists.
        active: false
        equations:
        - where: 'True'
          expression: sum(flow_cap, over=nodes) <= flow_cap_max_systemwide
        sub_expressions: {}
        slices: {}
        foreach:
        - techs
        - carriers
        where: flow_cap_max_systemwide
      flow_capacity_systemwide_min:
        title: ''
        description: Set a lower bound on flow capacity of a technology across 
          all nodes in which the technology exists.
        active: false
        equations:
        - where: 'True'
          expression: sum(flow_cap, over=nodes) >= flow_cap_min_systemwide
        sub_expressions: {}
        slices: {}
        foreach:
        - techs
        - carriers
        where: flow_cap_min_systemwide
      balance_conversion:
        title: ''
        description: Fix the relationship between a `conversion` technology's 
          outflow and consumption.
        active: true
        equations:
        - where: 'True'
          expression: sum(flow_out_inc_eff, over=carriers) == 
            sum(flow_in_inc_eff, over=carriers)
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: base_tech==conversion AND NOT include_storage==true
      flow_out_max:
        title: ''
        description: Set the upper bound of a technology's outflow.
        active: true
        equations:
        - where: 'True'
          expression: flow_out <= flow_cap * timestep_resolution * 
            flow_out_parasitic_eff
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: carrier_out
      flow_out_min:
        title: ''
        description: Set the lower bound of a technology's outflow.
        active: true
        equations:
        - where: 'True'
          expression: flow_out >= flow_cap * timestep_resolution * 
            flow_out_min_relative
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: flow_out_min_relative
      flow_in_max:
        title: ''
        description: Set the upper bound of a technology's inflow.
        active: true
        equations:
        - where: 'True'
          expression: flow_in <= flow_cap * timestep_resolution
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: carrier_in
      source_max:
        title: ''
        description: Set the upper bound of a `supply` technology's source 
          consumption.
        active: true
        equations:
        - where: 'True'
          expression: source_use <= timestep_resolution * source_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: source_cap
      storage_max:
        title: ''
        description: Set the upper bound of the amount of carrier a technology 
          can store.
        active: true
        equations:
        - where: 'True'
          expression: storage <= storage_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: storage
      storage_discharge_depth_limit:
        title: ''
        description: Set the lower bound of the stored carrier a technology must
          keep in reserve at all times.
        active: true
        equations:
        - where: 'True'
          expression: storage - storage_discharge_depth * storage_cap >= 0
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: storage AND storage_discharge_depth
      system_balance:
        title: ''
        description: Set the global carrier balance of the optimisation problem 
          by fixing the total production of a given carrier to equal the total 
          consumption of that carrier at every node in every timestep.
        active: true
        equations:
        - where: 'True'
          expression: sum(flow_out, over=techs) - sum(flow_in, over=techs) - 
            $flow_export + $unmet_demand_and_unused_supply == 0
        sub_expressions:
          flow_export:
          - where: any(carrier_export, over=techs)
            expression: sum(flow_export, over=techs)
          - where: NOT any(carrier_export, over=techs)
            expression: '0'
          unmet_demand_and_unused_supply:
          - where: config.ensure_feasibility==True
            expression: unmet_demand + unused_supply
          - where: NOT config.ensure_feasibility==True
            expression: '0'
        slices: {}
        foreach:
        - nodes
        - carriers
        - timesteps
        where: 'True'
      balance_demand:
        title: ''
        description: Set the upper bound on, or a fixed total of, that a demand 
          technology must dump to its sink in each timestep.
        active: true
        equations:
        - where: sink_use_equals
          expression: flow_in_inc_eff == sink_use_equals * $sink_scaler
        - where: NOT sink_use_equals AND sink_use_max
          expression: flow_in_inc_eff <= sink_use_max * $sink_scaler
        sub_expressions:
          sink_scaler:
          - where: sink_unit==per_area
            expression: area_use
          - where: sink_unit==per_cap
            expression: sum(flow_cap, over=carriers)
          - where: sink_unit==absolute
            expression: '1'
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: base_tech==demand
      balance_demand_min_use:
        title: ''
        description: Set the lower bound on the quantity of flow a `demand` 
          technology must dump to its sink in each timestep.
        active: true
        equations:
        - where: 'True'
          expression: flow_in_inc_eff >= sink_use_min * $sink_scaler
        sub_expressions:
          sink_scaler:
          - where: sink_unit==per_area
            expression: area_use
          - where: sink_unit==per_cap
            expression: sum(flow_cap, over=carriers)
          - where: sink_unit==absolute
            expression: '1'
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: sink_use_min AND NOT sink_use_equals AND base_tech==demand
      balance_supply_no_storage:
        title: ''
        description: Fix the outflow of a `supply` technology to its consumption
          of the available source.
        active: true
        equations:
        - where: 'True'
          expression: flow_out_inc_eff == source_use * source_eff
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: base_tech==supply AND NOT include_storage==True
      balance_supply_with_storage:
        title: ''
        description: Fix the outflow of a `supply` technology to its consumption
          of the available source, with a storage buffer to temporally offset 
          the outflow from source consumption.
        active: true
        equations:
        - where: 'True'
          expression: storage == $storage_previous_step + source_use * 
            source_eff - flow_out_inc_eff
        sub_expressions:
          storage_previous_step:
          - where: timesteps==get_val_at_index(timesteps=0) AND NOT 
              cyclic_storage==True
            expression: storage_initial * storage_cap
          - where: "(\n  (timesteps==get_val_at_index(timesteps=0) AND cyclic_storage==True)\n\
              \  OR NOT timesteps==get_val_at_index(timesteps=0)\n) AND NOT cluster_first_timestep==True"
            expression: (1 - storage_loss) ** roll(timestep_resolution, 
              timesteps=1) * roll(storage, timesteps=1)
          - where: cluster_first_timestep==True AND NOT 
              (timesteps==get_val_at_index(timesteps=0) AND NOT 
              cyclic_storage==True)
            expression: (1 - storage_loss) ** 
              select_from_lookup_arrays(timestep_resolution, 
              timesteps=lookup_cluster_last_timestep) * 
              select_from_lookup_arrays(storage, 
              timesteps=lookup_cluster_last_timestep)
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: storage AND base_tech==supply
      source_availability_supply:
        title: ''
        description: Set the upper bound on, or a fixed total of, a `supply` 
          technology's ability to consume its available resource.
        active: true
        equations:
        - where: source_use_equals
          expression: source_use == source_use_equals * $source_scaler
        - where: NOT source_use_equals AND source_use_max
          expression: source_use <= source_use_max * $source_scaler
        sub_expressions:
          source_scaler:
          - where: source_unit==per_area
            expression: area_use
          - where: source_unit==per_cap
            expression: sum(flow_cap, over=carriers)
          - where: source_unit==absolute
            expression: '1'
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: source_use AND (source_use_equals OR source_use_max)
      balance_supply_min_use:
        title: ''
        description: Set the lower bound on the quantity of its source a 
          `supply` technology must use in each timestep.
        active: true
        equations:
        - where: 'True'
          expression: source_use >= source_use_min * $source_scaler
        sub_expressions:
          source_scaler:
          - where: source_unit==per_area
            expression: area_use
          - where: source_unit==per_cap
            expression: sum(flow_cap, over=carriers)
          - where: source_unit==absolute
            expression: '1'
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: source_use_min AND NOT source_use_equals AND base_tech==supply
      balance_storage:
        title: ''
        description: Fix the quantity of carrier stored in a `storage` 
          technology at the end of each timestep based on the net flow of 
          carrier charged and discharged and the quantity of carrier stored at 
          the start of the timestep.
        active: true
        equations:
        - where: 'True'
          expression: "storage == $storage_previous_step -\n  sum(flow_out_inc_eff,
            over=carriers) + sum(flow_in_inc_eff, over=carriers)"
        sub_expressions:
          storage_previous_step:
          - where: timesteps==get_val_at_index(timesteps=0) AND NOT 
              cyclic_storage==True
            expression: storage_initial * storage_cap
          - where: "(\n  (timesteps==get_val_at_index(timesteps=0) AND cyclic_storage==True)\n\
              \  OR NOT timesteps==get_val_at_index(timesteps=0)\n) AND NOT cluster_first_timestep==True"
            expression: (1 - storage_loss) ** roll(timestep_resolution, 
              timesteps=1) * roll(storage, timesteps=1)
          - where: cluster_first_timestep==True AND NOT 
              (timesteps==get_val_at_index(timesteps=0) AND NOT 
              cyclic_storage==True)
            expression: (1 - storage_loss) ** 
              select_from_lookup_arrays(timestep_resolution, 
              timesteps=lookup_cluster_last_timestep) * 
              select_from_lookup_arrays(storage, 
              timesteps=lookup_cluster_last_timestep)
        slices: {}
        foreach:
        - nodes
        - techs
        - timesteps
        where: (include_storage==true or base_tech==storage) AND NOT 
          (base_tech==supply OR base_tech==demand)
      set_storage_initial:
        title: ''
        description: Fix the relationship between carrier stored in a `storage` 
          technology at the start and end of the whole model period.
        active: true
        equations:
        - where: 'True'
          expression: "storage[timesteps=$final_step] * (\n  (1 - storage_loss) **
            timestep_resolution[timesteps=$final_step]\n) == storage_initial * storage_cap"
        sub_expressions: {}
        slices:
          final_step:
          - where: 'True'
            expression: get_val_at_index(timesteps=-1)
        foreach:
        - nodes
        - techs
        where: storage AND storage_initial AND cyclic_storage==True
      balance_transmission:
        title: ''
        description: Fix the relationship between between carrier flowing into 
          and out of a `transmission` link in each timestep.
        active: true
        equations:
        - where: 'True'
          expression: sum(flow_out_inc_eff, over=[nodes, carriers]) == 
            sum(flow_in_inc_eff, over=[nodes, carriers])
        sub_expressions: {}
        slices: {}
        foreach:
        - techs
        - timesteps
        where: base_tech==transmission
      symmetric_transmission:
        title: ''
        description: Fix the flow capacity of two `transmission` technologies 
          representing the same link in the system.
        active: false
        equations:
        - where: 'True'
          expression: sum(flow_cap, over=carriers) == link_flow_cap
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        where: base_tech==transmission
      export_balance:
        title: ''
        description: Set the lower bound of a technology's outflow to a 
          technology's carrier export, for any technologies that can export 
          carriers out of the system.
        active: true
        equations:
        - where: 'True'
          expression: flow_out >= flow_export
        sub_expressions: {}
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: flow_export
      ramping_up:
        title: ''
        description: Set the upper bound on a technology's ability to ramp 
          outflow up beyond a certain percentage compared to the previous 
          timestep.
        active: true
        equations:
        - where: 'True'
          expression: $flow - roll($flow, timesteps=1) <= flow_ramping * 
            flow_cap
        sub_expressions:
          flow:
          - where: carrier_out AND NOT carrier_in
            expression: flow_out / timestep_resolution
          - where: carrier_in AND NOT carrier_out
            expression: flow_in / timestep_resolution
          - where: carrier_in AND carrier_out
            expression: (flow_out - flow_in) / timestep_resolution
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: flow_ramping AND NOT timesteps==get_val_at_index(timesteps=0)
      ramping_down:
        title: ''
        description: Set the upper bound on a technology's ability to ramp 
          outflow down beyond a certain percentage compared to the previous 
          timestep.
        active: true
        equations:
        - where: 'True'
          expression: -1 * flow_ramping * flow_cap <= $flow - roll($flow, 
            timesteps=1)
        sub_expressions:
          flow:
          - where: carrier_out AND NOT carrier_in
            expression: flow_out / timestep_resolution
          - where: carrier_in AND NOT carrier_out
            expression: flow_in / timestep_resolution
          - where: carrier_in AND carrier_out
            expression: (flow_out - flow_in) / timestep_resolution
        slices: {}
        foreach:
        - nodes
        - techs
        - carriers
        - timesteps
        where: flow_ramping AND NOT timesteps==get_val_at_index(timesteps=0)
      storage_capacity_units_milp:
        title: ''
        description: ''
        active: false
        equations: []
        sub_expressions: {}
        slices: {}
        foreach: []
        where: 'True'
      flow_capacity_units_milp:
        title: ''
        description: ''
        active: false
        equations: []
        sub_expressions: {}
        slices: {}
        foreach: []
        where: 'True'
      unit_capacity_max_systemwide_milp:
        title: ''
        description: ''
        active: false
        equations: []
        sub_expressions: {}
        slices: {}
        foreach: []
        where: 'True'
      unit_capacity_min_systemwide_milp:
        title: ''
        description: ''
        active: false
        equations: []
        sub_expressions: {}
        slices: {}
        foreach: []
        where: 'True'
    piecewise_constraints: {}
    objectives:
      min_cost_optimisation:
        title: ''
        description: Minimise the total cost of installing and operating all 
          technologies in the system. If multiple cost classes are present 
          (e.g., monetary and co2 emissions), the weighted sum of total costs is
          minimised. Cost class weights can be defined in the indexed parameter 
          `objective_cost_weights`.
        active: true
        equations:
        - where: any(cost, over=[nodes, techs, costs])
          expression: "sum(\n  sum(cost, over=[nodes, techs])\n  * objective_cost_weights,\n\
            \  over=costs\n) + $unmet_demand"
        - where: NOT any(cost, over=[nodes, techs, costs])
          expression: $unmet_demand
        sub_expressions:
          unmet_demand:
          - where: config.ensure_feasibility==True
            expression: "sum(\n  sum(unmet_demand - unused_supply, over=[carriers,
              nodes])\n  * timestep_weights,\n  over=timesteps\n) * bigM"
          - where: NOT config.ensure_feasibility==True
            expression: '0'
        slices: {}
        sense: minimise
    checks:
      must_have_base:
        where: not base_tech
        message: An abstract `base_tech` must be defined for every technology at
          every node.
        errors: raise
        active: true
      distance_only_for_transmission:
        where: not base_tech==transmission and (distance or 
          flow_in_eff_per_distance or flow_out_eff_per_distance or 
          cost_flow_cap_per_distance or cost_purchase_per_distance)
        message: Only transmission technologies can define `distance` or 
          `..._per_distance`.
        errors: raise
        active: true
      unbounded_flow_cap_cost:
        where: cost_flow_cap<0 AND not flow_cap_max
        message: Cannot have a negative `cost_flow_cap` as there is an unset 
          corresponding `flow_cap_max` constraint
        errors: raise
        active: true
      unbounded_storage_cap_cost:
        where: cost_storage_cap<0 AND not storage_cap_max
        message: Cannot have a negative `cost_storage_cap` as there is an unset 
          corresponding `storage_cap_max` constraint
        errors: raise
        active: true
      unbounded_area_use_cost:
        where: cost_area_use<0 AND not area_use_max
        message: Cannot have a negative `cost_area_use` as there is an unset 
          corresponding `area_use_max` constraint
        errors: raise
        active: true
      unbounded_source_use_cost:
        where: cost_source_cap<0 AND not source_use_max
        message: Cannot have a negative `cost_source_cap` as there is an unset 
          corresponding `source_use_max` constraint
        errors: raise
        active: true
      finite_source_use:
        where: source_use_equals==inf or sink_use_equals==inf
        message: Cannot include infinite values in 
          `source_use_equals`/`sink_use_equals`
        errors: raise
        active: true
      all_or_nothing_lat_lon:
        where: (any(latitude, over=nodes) or any(longitude, over=nodes)) and not
          (latitude or longitude)
        message: Must define node latitude and longitude for _all_ nodes or _no_
          nodes.
        errors: raise
        active: true
      export_only_for_outflows:
        where: carrier_export and not any(carrier_out, over=nodes)
        message: Export carriers must be one of the technology outflow carriers.
        errors: raise
        active: true
      storage_initial_max:
        where: storage_initial and (storage_initial<0 OR storage_initial>1)
        message: storage_initial is a fraction, requiring values within the 
          interval [0, 1].
        errors: raise
        active: true
      unit_commitment_only_for_units:
        where: integer_dispatch==True AND NOT cap_method==integer
        message: Cannot use the integer `integer_dispatch` unless the technology
          is using an integer unit capacities (`cap_method=integer`).
        errors: raise
        active: true
      conflicting_flow_caps:
        where: (flow_cap_max OR flow_cap_min) AND flow_cap_per_unit
        message: Cannot define both `flow_cap_per_unit` and 
          `flow_cap_max`/`flow_cap_min`
        errors: raise
        active: true
      conflicting_storage_caps:
        where: (storage_cap_max OR storage_cap_min) AND storage_cap_per_unit
        message: Cannot define both `storage_cap_per_unit` and 
          `storage_cap_max`/`storage_cap_min`
        errors: raise
        active: true
      lat_lons_out_of_range:
        where: latitude < -90 OR latitude > 90 OR longitude < -180 OR longitude 
          > 180
        message: Node latitude/longitude must be specified in WGS84 / EPSG4326 
          format.
        errors: warn
        active: true
      operate_mode_cyclic_storage:
        where: cyclic_storage==True AND (base_tech==storage OR 
          include_storage==True)
        message: 'Cyclic storage should be switched off in operate mode. Since the
          parameter defaults to True, make sure you explicitly set `cyclic_storage:
          false` for all your technologies with storage.'
        errors: raise
        active: true
runtime:
  applied_overrides: ''
  calliope_version_initialised: 0.7.0.dev7
  scenario:
  timings:
    preprocess_start: 1765151089.463416
    init_complete: 1765151089.886597
    build_start: 1765151101.503199
    build_complete: 1765151106.411371
    solve_start: 1765151109.12349
    solver_exit: 1765151115.237992
    postprocess_complete: 1765151115.278133
    solve_complete: 1765151115.278133
  termination_condition: optimal
